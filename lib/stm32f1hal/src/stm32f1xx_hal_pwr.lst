ARM GAS  /tmp/cciAnlD7.s 			page 1


   1              		.cpu cortex-m3
   2              		.eabi_attribute 20, 1	@ Tag_ABI_FP_denormal
   3              		.eabi_attribute 21, 1	@ Tag_ABI_FP_exceptions
   4              		.eabi_attribute 23, 3	@ Tag_ABI_FP_number_model
   5              		.eabi_attribute 24, 1	@ Tag_ABI_align8_needed
   6              		.eabi_attribute 25, 1	@ Tag_ABI_align8_preserved
   7              		.eabi_attribute 26, 1	@ Tag_ABI_enum_size
   8              		.eabi_attribute 30, 4	@ Tag_ABI_optimization_goals
   9              		.eabi_attribute 34, 1	@ Tag_CPU_unaligned_access
  10              		.eabi_attribute 18, 4	@ Tag_ABI_PCS_wchar_t
  11              		.file	"stm32f1xx_hal_pwr.c"
  12              	@ GNU C11 (15:6.3.1+svn253039-1build1) version 6.3.1 20170620 (arm-none-eabi)
  13              	@	compiled by GNU C version 7.2.0, GMP version 6.1.2, MPFR version 4.0.1-rc1, MPC version 1.1.0, is
  14              	@ warning: MPFR header version 4.0.1-rc1 differs from library version 4.0.1.
  15              	@ GGC heuristics: --param ggc-min-expand=100 --param ggc-min-heapsize=131072
  16              	@ options passed:  -I ./inc -I ./inc/Legacy -I ../cmsisstm32f1xx/inc
  17              	@ -I ../cmsiscore/inc -imultilib thumb/v7-m -D__USES_INITFINI__
  18              	@ -D STM32F103x6 -D RUN_FROM_FLASH=1 -D __c src/stm32f1xx_hal_pwr.c
  19              	@ -mcpu=cortex-m3 -mthumb -auxbase-strip bin/stm32f1xx_hal_pwr.o -g
  20              	@ -gdwarf-2 -Os -Wall -fomit-frame-pointer -fverbose-asm
  21              	@ options enabled:  -faggressive-loop-optimizations -falign-jumps
  22              	@ -falign-labels -falign-loops -fauto-inc-dec -fbranch-count-reg
  23              	@ -fcaller-saves -fchkp-check-incomplete-type -fchkp-check-read
  24              	@ -fchkp-check-write -fchkp-instrument-calls -fchkp-narrow-bounds
  25              	@ -fchkp-optimize -fchkp-store-bounds -fchkp-use-static-bounds
  26              	@ -fchkp-use-static-const-bounds -fchkp-use-wrappers
  27              	@ -fcombine-stack-adjustments -fcommon -fcompare-elim -fcprop-registers
  28              	@ -fcrossjumping -fcse-follow-jumps -fdefer-pop
  29              	@ -fdelete-null-pointer-checks -fdevirtualize -fdevirtualize-speculatively
  30              	@ -fdwarf2-cfi-asm -fearly-inlining -feliminate-unused-debug-types
  31              	@ -fexpensive-optimizations -fforward-propagate -ffunction-cse -fgcse
  32              	@ -fgcse-lm -fgnu-runtime -fgnu-unique -fguess-branch-probability
  33              	@ -fhoist-adjacent-loads -fident -fif-conversion -fif-conversion2
  34              	@ -findirect-inlining -finline -finline-atomics -finline-functions
  35              	@ -finline-functions-called-once -finline-small-functions -fipa-cp
  36              	@ -fipa-cp-alignment -fipa-icf -fipa-icf-functions -fipa-icf-variables
  37              	@ -fipa-profile -fipa-pure-const -fipa-ra -fipa-reference -fipa-sra
  38              	@ -fira-hoist-pressure -fira-share-save-slots -fira-share-spill-slots
  39              	@ -fisolate-erroneous-paths-dereference -fivopts -fkeep-static-consts
  40              	@ -fleading-underscore -flifetime-dse -flra-remat -flto-odr-type-merging
  41              	@ -fmath-errno -fmerge-constants -fmerge-debug-strings
  42              	@ -fmove-loop-invariants -fomit-frame-pointer -foptimize-sibling-calls
  43              	@ -fpartial-inlining -fpeephole -fpeephole2 -fplt -fprefetch-loop-arrays
  44              	@ -freg-struct-return -freorder-blocks -freorder-functions
  45              	@ -frerun-cse-after-loop -fsched-critical-path-heuristic
  46              	@ -fsched-dep-count-heuristic -fsched-group-heuristic -fsched-interblock
  47              	@ -fsched-last-insn-heuristic -fsched-pressure -fsched-rank-heuristic
  48              	@ -fsched-spec -fsched-spec-insn-heuristic -fsched-stalled-insns-dep
  49              	@ -fschedule-insns2 -fsection-anchors -fsemantic-interposition
  50              	@ -fshow-column -fsigned-zeros -fsplit-ivs-in-unroller -fsplit-wide-types
  51              	@ -fssa-backprop -fssa-phiopt -fstdarg-opt -fstrict-aliasing
  52              	@ -fstrict-overflow -fstrict-volatile-bitfields -fsync-libcalls
  53              	@ -fthread-jumps -ftoplevel-reorder -ftrapping-math -ftree-bit-ccp
  54              	@ -ftree-builtin-call-dce -ftree-ccp -ftree-ch -ftree-coalesce-vars
  55              	@ -ftree-copy-prop -ftree-cselim -ftree-dce -ftree-dominator-opts
  56              	@ -ftree-dse -ftree-forwprop -ftree-fre -ftree-loop-if-convert
  57              	@ -ftree-loop-im -ftree-loop-ivcanon -ftree-loop-optimize
ARM GAS  /tmp/cciAnlD7.s 			page 2


  58              	@ -ftree-parallelize-loops= -ftree-phiprop -ftree-pre -ftree-pta
  59              	@ -ftree-reassoc -ftree-scev-cprop -ftree-sink -ftree-slsr -ftree-sra
  60              	@ -ftree-switch-conversion -ftree-tail-merge -ftree-ter -ftree-vrp
  61              	@ -funit-at-a-time -fvar-tracking -fvar-tracking-assignments -fverbose-asm
  62              	@ -fzero-initialized-in-bss -masm-syntax-unified -mfix-cortex-m3-ldrd
  63              	@ -mlittle-endian -mpic-data-is-text-relative -msched-prolog -mthumb
  64              	@ -munaligned-access -mvectorize-with-neon-quad
  65              	
  66              		.text
  67              	.Ltext0:
  68              		.cfi_sections	.debug_frame
  69              		.align	1
  70              		.syntax unified
  71              		.thumb
  72              		.thumb_func
  73              		.fpu softvfp
  74              		.type	PWR_OverloadWfe, %function
  75              	PWR_OverloadWfe:
  76              	.LFB65:
  77              		.file 1 "src/stm32f1xx_hal_pwr.c"
   1:src/stm32f1xx_hal_pwr.c **** /**
   2:src/stm32f1xx_hal_pwr.c ****   ******************************************************************************
   3:src/stm32f1xx_hal_pwr.c ****   * @file    stm32f1xx_hal_pwr.c
   4:src/stm32f1xx_hal_pwr.c ****   * @author  MCD Application Team
   5:src/stm32f1xx_hal_pwr.c ****   * @brief   PWR HAL module driver.
   6:src/stm32f1xx_hal_pwr.c ****   *
   7:src/stm32f1xx_hal_pwr.c ****   *          This file provides firmware functions to manage the following
   8:src/stm32f1xx_hal_pwr.c ****   *          functionalities of the Power Controller (PWR) peripheral:
   9:src/stm32f1xx_hal_pwr.c ****   *           + Initialization/de-initialization functions
  10:src/stm32f1xx_hal_pwr.c ****   *           + Peripheral Control functions 
  11:src/stm32f1xx_hal_pwr.c ****   *
  12:src/stm32f1xx_hal_pwr.c ****   ******************************************************************************
  13:src/stm32f1xx_hal_pwr.c ****   * @attention
  14:src/stm32f1xx_hal_pwr.c ****   *
  15:src/stm32f1xx_hal_pwr.c ****   * <h2><center>&copy; Copyright (c) 2016 STMicroelectronics.
  16:src/stm32f1xx_hal_pwr.c ****   * All rights reserved.</center></h2>
  17:src/stm32f1xx_hal_pwr.c ****   *
  18:src/stm32f1xx_hal_pwr.c ****   * This software component is licensed by ST under BSD 3-Clause license,
  19:src/stm32f1xx_hal_pwr.c ****   * the "License"; You may not use this file except in compliance with the
  20:src/stm32f1xx_hal_pwr.c ****   * License. You may obtain a copy of the License at:
  21:src/stm32f1xx_hal_pwr.c ****   *                        opensource.org/licenses/BSD-3-Clause
  22:src/stm32f1xx_hal_pwr.c ****   *
  23:src/stm32f1xx_hal_pwr.c ****   ******************************************************************************
  24:src/stm32f1xx_hal_pwr.c ****   */
  25:src/stm32f1xx_hal_pwr.c **** 
  26:src/stm32f1xx_hal_pwr.c **** /* Includes ------------------------------------------------------------------*/
  27:src/stm32f1xx_hal_pwr.c **** #include "stm32f1xx_hal.h"
  28:src/stm32f1xx_hal_pwr.c **** 
  29:src/stm32f1xx_hal_pwr.c **** /** @addtogroup STM32F1xx_HAL_Driver
  30:src/stm32f1xx_hal_pwr.c ****   * @{
  31:src/stm32f1xx_hal_pwr.c ****   */
  32:src/stm32f1xx_hal_pwr.c **** 
  33:src/stm32f1xx_hal_pwr.c **** /** @defgroup PWR PWR
  34:src/stm32f1xx_hal_pwr.c ****   * @brief    PWR HAL module driver
  35:src/stm32f1xx_hal_pwr.c ****   * @{
  36:src/stm32f1xx_hal_pwr.c ****   */
  37:src/stm32f1xx_hal_pwr.c **** 
ARM GAS  /tmp/cciAnlD7.s 			page 3


  38:src/stm32f1xx_hal_pwr.c **** #ifdef HAL_PWR_MODULE_ENABLED
  39:src/stm32f1xx_hal_pwr.c **** 
  40:src/stm32f1xx_hal_pwr.c **** /* Private typedef -----------------------------------------------------------*/
  41:src/stm32f1xx_hal_pwr.c **** /* Private define ------------------------------------------------------------*/
  42:src/stm32f1xx_hal_pwr.c **** 
  43:src/stm32f1xx_hal_pwr.c **** /** @defgroup PWR_Private_Constants PWR Private Constants
  44:src/stm32f1xx_hal_pwr.c ****   * @{
  45:src/stm32f1xx_hal_pwr.c ****   */
  46:src/stm32f1xx_hal_pwr.c ****   
  47:src/stm32f1xx_hal_pwr.c **** /** @defgroup PWR_PVD_Mode_Mask PWR PVD Mode Mask
  48:src/stm32f1xx_hal_pwr.c ****   * @{
  49:src/stm32f1xx_hal_pwr.c ****   */ 
  50:src/stm32f1xx_hal_pwr.c **** #define PVD_MODE_IT               0x00010000U
  51:src/stm32f1xx_hal_pwr.c **** #define PVD_MODE_EVT              0x00020000U
  52:src/stm32f1xx_hal_pwr.c **** #define PVD_RISING_EDGE           0x00000001U
  53:src/stm32f1xx_hal_pwr.c **** #define PVD_FALLING_EDGE          0x00000002U
  54:src/stm32f1xx_hal_pwr.c **** /**
  55:src/stm32f1xx_hal_pwr.c ****   * @}
  56:src/stm32f1xx_hal_pwr.c ****   */
  57:src/stm32f1xx_hal_pwr.c **** 
  58:src/stm32f1xx_hal_pwr.c **** 
  59:src/stm32f1xx_hal_pwr.c **** /** @defgroup PWR_register_alias_address PWR Register alias address
  60:src/stm32f1xx_hal_pwr.c ****   * @{
  61:src/stm32f1xx_hal_pwr.c ****   */ 
  62:src/stm32f1xx_hal_pwr.c **** /* ------------- PWR registers bit address in the alias region ---------------*/
  63:src/stm32f1xx_hal_pwr.c **** #define PWR_OFFSET               (PWR_BASE - PERIPH_BASE)
  64:src/stm32f1xx_hal_pwr.c **** #define PWR_CR_OFFSET            0x00U
  65:src/stm32f1xx_hal_pwr.c **** #define PWR_CSR_OFFSET           0x04U
  66:src/stm32f1xx_hal_pwr.c **** #define PWR_CR_OFFSET_BB         (PWR_OFFSET + PWR_CR_OFFSET)
  67:src/stm32f1xx_hal_pwr.c **** #define PWR_CSR_OFFSET_BB        (PWR_OFFSET + PWR_CSR_OFFSET)
  68:src/stm32f1xx_hal_pwr.c **** /**
  69:src/stm32f1xx_hal_pwr.c ****   * @}
  70:src/stm32f1xx_hal_pwr.c ****   */
  71:src/stm32f1xx_hal_pwr.c ****    
  72:src/stm32f1xx_hal_pwr.c **** /** @defgroup PWR_CR_register_alias PWR CR Register alias address
  73:src/stm32f1xx_hal_pwr.c ****   * @{
  74:src/stm32f1xx_hal_pwr.c ****   */  
  75:src/stm32f1xx_hal_pwr.c **** /* --- CR Register ---*/
  76:src/stm32f1xx_hal_pwr.c **** /* Alias word address of LPSDSR bit */
  77:src/stm32f1xx_hal_pwr.c **** #define LPSDSR_BIT_NUMBER        PWR_CR_LPDS_Pos
  78:src/stm32f1xx_hal_pwr.c **** #define CR_LPSDSR_BB             ((uint32_t)(PERIPH_BB_BASE + (PWR_CR_OFFSET_BB * 32U) + (LPSDSR_BI
  79:src/stm32f1xx_hal_pwr.c **** 
  80:src/stm32f1xx_hal_pwr.c **** /* Alias word address of DBP bit */
  81:src/stm32f1xx_hal_pwr.c **** #define DBP_BIT_NUMBER            PWR_CR_DBP_Pos
  82:src/stm32f1xx_hal_pwr.c **** #define CR_DBP_BB                ((uint32_t)(PERIPH_BB_BASE + (PWR_CR_OFFSET_BB * 32U) + (DBP_BIT_N
  83:src/stm32f1xx_hal_pwr.c **** 
  84:src/stm32f1xx_hal_pwr.c **** /* Alias word address of PVDE bit */
  85:src/stm32f1xx_hal_pwr.c **** #define PVDE_BIT_NUMBER           PWR_CR_PVDE_Pos
  86:src/stm32f1xx_hal_pwr.c **** #define CR_PVDE_BB               ((uint32_t)(PERIPH_BB_BASE + (PWR_CR_OFFSET_BB * 32U) + (PVDE_BIT_
  87:src/stm32f1xx_hal_pwr.c **** 
  88:src/stm32f1xx_hal_pwr.c **** /**
  89:src/stm32f1xx_hal_pwr.c ****   * @}
  90:src/stm32f1xx_hal_pwr.c ****   */
  91:src/stm32f1xx_hal_pwr.c **** 
  92:src/stm32f1xx_hal_pwr.c **** /** @defgroup PWR_CSR_register_alias PWR CSR Register alias address
  93:src/stm32f1xx_hal_pwr.c ****   * @{
  94:src/stm32f1xx_hal_pwr.c ****   */
ARM GAS  /tmp/cciAnlD7.s 			page 4


  95:src/stm32f1xx_hal_pwr.c **** 
  96:src/stm32f1xx_hal_pwr.c **** /* --- CSR Register ---*/
  97:src/stm32f1xx_hal_pwr.c **** /* Alias word address of EWUP1 bit */
  98:src/stm32f1xx_hal_pwr.c **** #define CSR_EWUP_BB(VAL)         ((uint32_t)(PERIPH_BB_BASE + (PWR_CSR_OFFSET_BB * 32U) + (POSITION
  99:src/stm32f1xx_hal_pwr.c **** /**
 100:src/stm32f1xx_hal_pwr.c ****   * @}
 101:src/stm32f1xx_hal_pwr.c ****   */
 102:src/stm32f1xx_hal_pwr.c ****   
 103:src/stm32f1xx_hal_pwr.c **** /**
 104:src/stm32f1xx_hal_pwr.c ****   * @}
 105:src/stm32f1xx_hal_pwr.c ****   */
 106:src/stm32f1xx_hal_pwr.c **** 
 107:src/stm32f1xx_hal_pwr.c **** /* Private variables ---------------------------------------------------------*/
 108:src/stm32f1xx_hal_pwr.c **** /* Private function prototypes -----------------------------------------------*/
 109:src/stm32f1xx_hal_pwr.c **** /** @defgroup PWR_Private_Functions PWR Private Functions
 110:src/stm32f1xx_hal_pwr.c ****  * brief   WFE cortex command overloaded for HAL_PWR_EnterSTOPMode usage only (see Workaround secti
 111:src/stm32f1xx_hal_pwr.c ****  * @{
 112:src/stm32f1xx_hal_pwr.c ****  */
 113:src/stm32f1xx_hal_pwr.c **** static void PWR_OverloadWfe(void);
 114:src/stm32f1xx_hal_pwr.c **** 
 115:src/stm32f1xx_hal_pwr.c **** /* Private functions ---------------------------------------------------------*/
 116:src/stm32f1xx_hal_pwr.c **** __NOINLINE
 117:src/stm32f1xx_hal_pwr.c **** static void PWR_OverloadWfe(void)
 118:src/stm32f1xx_hal_pwr.c **** {
  78              		.loc 1 118 0
  79              		.cfi_startproc
  80              		@ args = 0, pretend = 0, frame = 0
  81              		@ frame_needed = 0, uses_anonymous_args = 0
  82              		@ link register save eliminated.
 119:src/stm32f1xx_hal_pwr.c ****   __asm volatile( "wfe" );
  83              		.loc 1 119 0
  84              		.syntax unified
  85              	@ 119 "src/stm32f1xx_hal_pwr.c" 1
  86 0000 20BF     		wfe
  87              	@ 0 "" 2
 120:src/stm32f1xx_hal_pwr.c ****   __asm volatile( "nop" );
  88              		.loc 1 120 0
  89              	@ 120 "src/stm32f1xx_hal_pwr.c" 1
  90 0002 00BF     		nop
  91              	@ 0 "" 2
  92              		.thumb
  93              		.syntax unified
  94 0004 7047     		bx	lr	@
  95              		.cfi_endproc
  96              	.LFE65:
  97              		.size	PWR_OverloadWfe, .-PWR_OverloadWfe
  98              		.align	1
  99              		.global	HAL_PWR_DeInit
 100              		.syntax unified
 101              		.thumb
 102              		.thumb_func
 103              		.fpu softvfp
 104              		.type	HAL_PWR_DeInit, %function
 105              	HAL_PWR_DeInit:
 106              	.LFB66:
 121:src/stm32f1xx_hal_pwr.c **** }
 122:src/stm32f1xx_hal_pwr.c **** 
ARM GAS  /tmp/cciAnlD7.s 			page 5


 123:src/stm32f1xx_hal_pwr.c **** /**
 124:src/stm32f1xx_hal_pwr.c ****   * @}
 125:src/stm32f1xx_hal_pwr.c ****   */
 126:src/stm32f1xx_hal_pwr.c **** 
 127:src/stm32f1xx_hal_pwr.c **** 
 128:src/stm32f1xx_hal_pwr.c **** /** @defgroup PWR_Exported_Functions PWR Exported Functions
 129:src/stm32f1xx_hal_pwr.c ****   * @{
 130:src/stm32f1xx_hal_pwr.c ****   */
 131:src/stm32f1xx_hal_pwr.c **** 
 132:src/stm32f1xx_hal_pwr.c **** /** @defgroup PWR_Exported_Functions_Group1 Initialization and de-initialization functions 
 133:src/stm32f1xx_hal_pwr.c ****   *  @brief   Initialization and de-initialization functions
 134:src/stm32f1xx_hal_pwr.c ****   *
 135:src/stm32f1xx_hal_pwr.c **** @verbatim
 136:src/stm32f1xx_hal_pwr.c ****  ===============================================================================
 137:src/stm32f1xx_hal_pwr.c ****               ##### Initialization and de-initialization functions #####
 138:src/stm32f1xx_hal_pwr.c ****  ===============================================================================
 139:src/stm32f1xx_hal_pwr.c ****     [..]
 140:src/stm32f1xx_hal_pwr.c ****       After reset, the backup domain (RTC registers, RTC backup data
 141:src/stm32f1xx_hal_pwr.c ****       registers) is protected against possible unwanted
 142:src/stm32f1xx_hal_pwr.c ****       write accesses.
 143:src/stm32f1xx_hal_pwr.c ****       To enable access to the RTC Domain and RTC registers, proceed as follows:
 144:src/stm32f1xx_hal_pwr.c ****         (+) Enable the Power Controller (PWR) APB1 interface clock using the
 145:src/stm32f1xx_hal_pwr.c ****             __HAL_RCC_PWR_CLK_ENABLE() macro.
 146:src/stm32f1xx_hal_pwr.c ****         (+) Enable access to RTC domain using the HAL_PWR_EnableBkUpAccess() function.
 147:src/stm32f1xx_hal_pwr.c **** 
 148:src/stm32f1xx_hal_pwr.c **** @endverbatim
 149:src/stm32f1xx_hal_pwr.c ****   * @{
 150:src/stm32f1xx_hal_pwr.c ****   */
 151:src/stm32f1xx_hal_pwr.c **** 
 152:src/stm32f1xx_hal_pwr.c **** /**
 153:src/stm32f1xx_hal_pwr.c ****   * @brief  Deinitializes the PWR peripheral registers to their default reset values.  
 154:src/stm32f1xx_hal_pwr.c ****   * @retval None
 155:src/stm32f1xx_hal_pwr.c ****   */
 156:src/stm32f1xx_hal_pwr.c **** void HAL_PWR_DeInit(void)
 157:src/stm32f1xx_hal_pwr.c **** {
 107              		.loc 1 157 0
 108              		.cfi_startproc
 109              		@ args = 0, pretend = 0, frame = 0
 110              		@ frame_needed = 0, uses_anonymous_args = 0
 111              		@ link register save eliminated.
 158:src/stm32f1xx_hal_pwr.c ****   __HAL_RCC_PWR_FORCE_RESET();
 112              		.loc 1 158 0
 113 0006 054B     		ldr	r3, .L3	@ tmp114,
 114 0008 1A69     		ldr	r2, [r3, #16]	@ _2, MEM[(struct RCC_TypeDef *)1073876992B].APB1RSTR
 115 000a 42F08052 		orr	r2, r2, #268435456	@ _3, _2,
 116 000e 1A61     		str	r2, [r3, #16]	@ _3, MEM[(struct RCC_TypeDef *)1073876992B].APB1RSTR
 159:src/stm32f1xx_hal_pwr.c ****   __HAL_RCC_PWR_RELEASE_RESET();
 117              		.loc 1 159 0
 118 0010 1A69     		ldr	r2, [r3, #16]	@ _5, MEM[(struct RCC_TypeDef *)1073876992B].APB1RSTR
 119 0012 22F08052 		bic	r2, r2, #268435456	@ _6, _5,
 120 0016 1A61     		str	r2, [r3, #16]	@ _6, MEM[(struct RCC_TypeDef *)1073876992B].APB1RSTR
 121 0018 7047     		bx	lr	@
 122              	.L4:
 123 001a 00BF     		.align	2
 124              	.L3:
 125 001c 00100240 		.word	1073876992
 126              		.cfi_endproc
ARM GAS  /tmp/cciAnlD7.s 			page 6


 127              	.LFE66:
 128              		.size	HAL_PWR_DeInit, .-HAL_PWR_DeInit
 129              		.align	1
 130              		.global	HAL_PWR_EnableBkUpAccess
 131              		.syntax unified
 132              		.thumb
 133              		.thumb_func
 134              		.fpu softvfp
 135              		.type	HAL_PWR_EnableBkUpAccess, %function
 136              	HAL_PWR_EnableBkUpAccess:
 137              	.LFB67:
 160:src/stm32f1xx_hal_pwr.c **** }
 161:src/stm32f1xx_hal_pwr.c **** 
 162:src/stm32f1xx_hal_pwr.c **** /**
 163:src/stm32f1xx_hal_pwr.c ****   * @brief  Enables access to the backup domain (RTC registers, RTC
 164:src/stm32f1xx_hal_pwr.c ****   *         backup data registers ).
 165:src/stm32f1xx_hal_pwr.c ****   * @note   If the HSE divided by 128 is used as the RTC clock, the
 166:src/stm32f1xx_hal_pwr.c ****   *         Backup Domain Access should be kept enabled.
 167:src/stm32f1xx_hal_pwr.c ****   * @retval None
 168:src/stm32f1xx_hal_pwr.c ****   */
 169:src/stm32f1xx_hal_pwr.c **** void HAL_PWR_EnableBkUpAccess(void)
 170:src/stm32f1xx_hal_pwr.c **** {
 138              		.loc 1 170 0
 139              		.cfi_startproc
 140              		@ args = 0, pretend = 0, frame = 0
 141              		@ frame_needed = 0, uses_anonymous_args = 0
 142              		@ link register save eliminated.
 171:src/stm32f1xx_hal_pwr.c ****   /* Enable access to RTC and backup registers */
 172:src/stm32f1xx_hal_pwr.c ****   *(__IO uint32_t *) CR_DBP_BB = (uint32_t)ENABLE;
 143              		.loc 1 172 0
 144 0020 0122     		movs	r2, #1	@ tmp111,
 145 0022 014B     		ldr	r3, .L6	@ tmp110,
 146 0024 1A60     		str	r2, [r3]	@ tmp111, MEM[(volatile uint32_t *)1108213792B]
 147 0026 7047     		bx	lr	@
 148              	.L7:
 149              		.align	2
 150              	.L6:
 151 0028 20000E42 		.word	1108213792
 152              		.cfi_endproc
 153              	.LFE67:
 154              		.size	HAL_PWR_EnableBkUpAccess, .-HAL_PWR_EnableBkUpAccess
 155              		.align	1
 156              		.global	HAL_PWR_DisableBkUpAccess
 157              		.syntax unified
 158              		.thumb
 159              		.thumb_func
 160              		.fpu softvfp
 161              		.type	HAL_PWR_DisableBkUpAccess, %function
 162              	HAL_PWR_DisableBkUpAccess:
 163              	.LFB68:
 173:src/stm32f1xx_hal_pwr.c **** }
 174:src/stm32f1xx_hal_pwr.c **** 
 175:src/stm32f1xx_hal_pwr.c **** /**
 176:src/stm32f1xx_hal_pwr.c ****   * @brief  Disables access to the backup domain (RTC registers, RTC
 177:src/stm32f1xx_hal_pwr.c ****   *         backup data registers).
 178:src/stm32f1xx_hal_pwr.c ****   * @note   If the HSE divided by 128 is used as the RTC clock, the
 179:src/stm32f1xx_hal_pwr.c ****   *         Backup Domain Access should be kept enabled.
ARM GAS  /tmp/cciAnlD7.s 			page 7


 180:src/stm32f1xx_hal_pwr.c ****   * @retval None
 181:src/stm32f1xx_hal_pwr.c ****   */
 182:src/stm32f1xx_hal_pwr.c **** void HAL_PWR_DisableBkUpAccess(void)
 183:src/stm32f1xx_hal_pwr.c **** {
 164              		.loc 1 183 0
 165              		.cfi_startproc
 166              		@ args = 0, pretend = 0, frame = 0
 167              		@ frame_needed = 0, uses_anonymous_args = 0
 168              		@ link register save eliminated.
 184:src/stm32f1xx_hal_pwr.c ****   /* Disable access to RTC and backup registers */
 185:src/stm32f1xx_hal_pwr.c ****   *(__IO uint32_t *) CR_DBP_BB = (uint32_t)DISABLE;
 169              		.loc 1 185 0
 170 002c 0022     		movs	r2, #0	@ tmp111,
 171 002e 014B     		ldr	r3, .L9	@ tmp110,
 172 0030 1A60     		str	r2, [r3]	@ tmp111, MEM[(volatile uint32_t *)1108213792B]
 173 0032 7047     		bx	lr	@
 174              	.L10:
 175              		.align	2
 176              	.L9:
 177 0034 20000E42 		.word	1108213792
 178              		.cfi_endproc
 179              	.LFE68:
 180              		.size	HAL_PWR_DisableBkUpAccess, .-HAL_PWR_DisableBkUpAccess
 181              		.align	1
 182              		.global	HAL_PWR_ConfigPVD
 183              		.syntax unified
 184              		.thumb
 185              		.thumb_func
 186              		.fpu softvfp
 187              		.type	HAL_PWR_ConfigPVD, %function
 188              	HAL_PWR_ConfigPVD:
 189              	.LFB69:
 186:src/stm32f1xx_hal_pwr.c **** }
 187:src/stm32f1xx_hal_pwr.c **** 
 188:src/stm32f1xx_hal_pwr.c **** /**
 189:src/stm32f1xx_hal_pwr.c ****   * @}
 190:src/stm32f1xx_hal_pwr.c ****   */
 191:src/stm32f1xx_hal_pwr.c **** 
 192:src/stm32f1xx_hal_pwr.c **** /** @defgroup PWR_Exported_Functions_Group2 Peripheral Control functions 
 193:src/stm32f1xx_hal_pwr.c ****   * @brief    Low Power modes configuration functions
 194:src/stm32f1xx_hal_pwr.c ****   *
 195:src/stm32f1xx_hal_pwr.c **** @verbatim
 196:src/stm32f1xx_hal_pwr.c ****  ===============================================================================
 197:src/stm32f1xx_hal_pwr.c ****                  ##### Peripheral Control functions #####
 198:src/stm32f1xx_hal_pwr.c ****  ===============================================================================
 199:src/stm32f1xx_hal_pwr.c ****      
 200:src/stm32f1xx_hal_pwr.c ****     *** PVD configuration ***
 201:src/stm32f1xx_hal_pwr.c ****     =========================
 202:src/stm32f1xx_hal_pwr.c ****     [..]
 203:src/stm32f1xx_hal_pwr.c ****       (+) The PVD is used to monitor the VDD power supply by comparing it to a
 204:src/stm32f1xx_hal_pwr.c ****           threshold selected by the PVD Level (PLS[2:0] bits in the PWR_CR).
 205:src/stm32f1xx_hal_pwr.c **** 
 206:src/stm32f1xx_hal_pwr.c ****       (+) A PVDO flag is available to indicate if VDD/VDDA is higher or lower
 207:src/stm32f1xx_hal_pwr.c ****           than the PVD threshold. This event is internally connected to the EXTI
 208:src/stm32f1xx_hal_pwr.c ****           line16 and can generate an interrupt if enabled. This is done through
 209:src/stm32f1xx_hal_pwr.c ****           __HAL_PVD_EXTI_ENABLE_IT() macro.
 210:src/stm32f1xx_hal_pwr.c ****       (+) The PVD is stopped in Standby mode.
ARM GAS  /tmp/cciAnlD7.s 			page 8


 211:src/stm32f1xx_hal_pwr.c **** 
 212:src/stm32f1xx_hal_pwr.c ****     *** WakeUp pin configuration ***
 213:src/stm32f1xx_hal_pwr.c ****     ================================
 214:src/stm32f1xx_hal_pwr.c ****     [..]
 215:src/stm32f1xx_hal_pwr.c ****       (+) WakeUp pin is used to wake up the system from Standby mode. This pin is
 216:src/stm32f1xx_hal_pwr.c ****           forced in input pull-down configuration and is active on rising edges.
 217:src/stm32f1xx_hal_pwr.c ****       (+) There is one WakeUp pin:
 218:src/stm32f1xx_hal_pwr.c ****           WakeUp Pin 1 on PA.00.
 219:src/stm32f1xx_hal_pwr.c **** 
 220:src/stm32f1xx_hal_pwr.c ****     [..]
 221:src/stm32f1xx_hal_pwr.c **** 
 222:src/stm32f1xx_hal_pwr.c ****     *** Low Power modes configuration ***
 223:src/stm32f1xx_hal_pwr.c ****     =====================================
 224:src/stm32f1xx_hal_pwr.c ****      [..]
 225:src/stm32f1xx_hal_pwr.c ****       The device features 3 low-power modes:
 226:src/stm32f1xx_hal_pwr.c ****       (+) Sleep mode: CPU clock off, all peripherals including Cortex-M3 core peripherals like 
 227:src/stm32f1xx_hal_pwr.c ****                       NVIC, SysTick, etc. are kept running
 228:src/stm32f1xx_hal_pwr.c ****       (+) Stop mode: All clocks are stopped
 229:src/stm32f1xx_hal_pwr.c ****       (+) Standby mode: 1.8V domain powered off
 230:src/stm32f1xx_hal_pwr.c ****   
 231:src/stm32f1xx_hal_pwr.c ****   
 232:src/stm32f1xx_hal_pwr.c ****    *** Sleep mode ***
 233:src/stm32f1xx_hal_pwr.c ****    ==================
 234:src/stm32f1xx_hal_pwr.c ****     [..]
 235:src/stm32f1xx_hal_pwr.c ****       (+) Entry:
 236:src/stm32f1xx_hal_pwr.c ****           The Sleep mode is entered by using the HAL_PWR_EnterSLEEPMode(PWR_MAINREGULATOR_ON, PWR_S
 237:src/stm32f1xx_hal_pwr.c ****               functions with
 238:src/stm32f1xx_hal_pwr.c ****           (++) PWR_SLEEPENTRY_WFI: enter SLEEP mode with WFI instruction
 239:src/stm32f1xx_hal_pwr.c ****           (++) PWR_SLEEPENTRY_WFE: enter SLEEP mode with WFE instruction
 240:src/stm32f1xx_hal_pwr.c ****      
 241:src/stm32f1xx_hal_pwr.c ****       (+) Exit:
 242:src/stm32f1xx_hal_pwr.c ****         (++) WFI entry mode, Any peripheral interrupt acknowledged by the nested vectored interrupt
 243:src/stm32f1xx_hal_pwr.c ****              controller (NVIC) can wake up the device from Sleep mode.
 244:src/stm32f1xx_hal_pwr.c ****         (++) WFE entry mode, Any wakeup event can wake up the device from Sleep mode.
 245:src/stm32f1xx_hal_pwr.c ****            (+++) Any peripheral interrupt w/o NVIC configuration & SEVONPEND bit set in the Cortex 
 246:src/stm32f1xx_hal_pwr.c ****            (+++) Any EXTI Line (Internal or External) configured in Event mode
 247:src/stm32f1xx_hal_pwr.c **** 
 248:src/stm32f1xx_hal_pwr.c ****    *** Stop mode ***
 249:src/stm32f1xx_hal_pwr.c ****    =================
 250:src/stm32f1xx_hal_pwr.c ****     [..]
 251:src/stm32f1xx_hal_pwr.c ****       The Stop mode is based on the Cortex-M3 deepsleep mode combined with peripheral
 252:src/stm32f1xx_hal_pwr.c ****       clock gating. The voltage regulator can be configured either in normal or low-power mode.
 253:src/stm32f1xx_hal_pwr.c ****       In Stop mode, all clocks in the 1.8 V domain are stopped, the PLL, the HSI and the HSE RC 
 254:src/stm32f1xx_hal_pwr.c ****       oscillators are disabled. SRAM and register contents are preserved.
 255:src/stm32f1xx_hal_pwr.c ****       In Stop mode, all I/O pins keep the same state as in Run mode.
 256:src/stm32f1xx_hal_pwr.c **** 
 257:src/stm32f1xx_hal_pwr.c ****       (+) Entry:
 258:src/stm32f1xx_hal_pwr.c ****            The Stop mode is entered using the HAL_PWR_EnterSTOPMode(PWR_REGULATOR_VALUE, PWR_SLEEPE
 259:src/stm32f1xx_hal_pwr.c ****              function with:
 260:src/stm32f1xx_hal_pwr.c ****           (++) PWR_REGULATOR_VALUE= PWR_MAINREGULATOR_ON: Main regulator ON.
 261:src/stm32f1xx_hal_pwr.c ****           (++) PWR_REGULATOR_VALUE= PWR_LOWPOWERREGULATOR_ON: Low Power regulator ON.
 262:src/stm32f1xx_hal_pwr.c ****           (++) PWR_SLEEPENTRY_WFx= PWR_SLEEPENTRY_WFI: enter STOP mode with WFI instruction
 263:src/stm32f1xx_hal_pwr.c ****           (++) PWR_SLEEPENTRY_WFx= PWR_SLEEPENTRY_WFE: enter STOP mode with WFE instruction
 264:src/stm32f1xx_hal_pwr.c ****       (+) Exit:
 265:src/stm32f1xx_hal_pwr.c ****           (++) WFI entry mode, Any EXTI Line (Internal or External) configured in Interrupt mode wi
 266:src/stm32f1xx_hal_pwr.c ****           (++) WFE entry mode, Any EXTI Line (Internal or External) configured in Event mode.
 267:src/stm32f1xx_hal_pwr.c **** 
ARM GAS  /tmp/cciAnlD7.s 			page 9


 268:src/stm32f1xx_hal_pwr.c ****    *** Standby mode ***
 269:src/stm32f1xx_hal_pwr.c ****    ====================
 270:src/stm32f1xx_hal_pwr.c ****      [..]
 271:src/stm32f1xx_hal_pwr.c ****       The Standby mode allows to achieve the lowest power consumption. It is based on the
 272:src/stm32f1xx_hal_pwr.c ****       Cortex-M3 deepsleep mode, with the voltage regulator disabled. The 1.8 V domain is 
 273:src/stm32f1xx_hal_pwr.c ****       consequently powered off. The PLL, the HSI oscillator and the HSE oscillator are also 
 274:src/stm32f1xx_hal_pwr.c ****       switched off. SRAM and register contents are lost except for registers in the Backup domain 
 275:src/stm32f1xx_hal_pwr.c ****       and Standby circuitry
 276:src/stm32f1xx_hal_pwr.c ****       
 277:src/stm32f1xx_hal_pwr.c ****       (+) Entry:
 278:src/stm32f1xx_hal_pwr.c ****         (++) The Standby mode is entered using the HAL_PWR_EnterSTANDBYMode() function.
 279:src/stm32f1xx_hal_pwr.c ****       (+) Exit:
 280:src/stm32f1xx_hal_pwr.c ****         (++) WKUP pin rising edge, RTC alarm event rising edge, external Reset in 
 281:src/stm32f1xx_hal_pwr.c ****              NRSTpin, IWDG Reset
 282:src/stm32f1xx_hal_pwr.c **** 
 283:src/stm32f1xx_hal_pwr.c ****    *** Auto-wakeup (AWU) from low-power mode ***
 284:src/stm32f1xx_hal_pwr.c ****        =============================================
 285:src/stm32f1xx_hal_pwr.c ****        [..]
 286:src/stm32f1xx_hal_pwr.c ****         
 287:src/stm32f1xx_hal_pwr.c ****        (+) The MCU can be woken up from low-power mode by an RTC Alarm event, 
 288:src/stm32f1xx_hal_pwr.c ****            without depending on an external interrupt (Auto-wakeup mode).
 289:src/stm32f1xx_hal_pwr.c ****    
 290:src/stm32f1xx_hal_pwr.c ****        (+) RTC auto-wakeup (AWU) from the Stop and Standby modes
 291:src/stm32f1xx_hal_pwr.c **** 
 292:src/stm32f1xx_hal_pwr.c ****            (++) To wake up from the Stop mode with an RTC alarm event, it is necessary to 
 293:src/stm32f1xx_hal_pwr.c ****                 configure the RTC to generate the RTC alarm using the HAL_RTC_SetAlarm_IT() functio
 294:src/stm32f1xx_hal_pwr.c **** 
 295:src/stm32f1xx_hal_pwr.c ****    *** PWR Workarounds linked to Silicon Limitation ***
 296:src/stm32f1xx_hal_pwr.c ****        ====================================================
 297:src/stm32f1xx_hal_pwr.c ****        [..]
 298:src/stm32f1xx_hal_pwr.c ****        Below the list of all silicon limitations known on STM32F1xx prouct.
 299:src/stm32f1xx_hal_pwr.c **** 
 300:src/stm32f1xx_hal_pwr.c ****        (#)Workarounds Implemented inside PWR HAL Driver
 301:src/stm32f1xx_hal_pwr.c ****           (##)Debugging Stop mode with WFE entry - overloaded the WFE by an internal function    
 302:src/stm32f1xx_hal_pwr.c ****         
 303:src/stm32f1xx_hal_pwr.c **** @endverbatim
 304:src/stm32f1xx_hal_pwr.c ****   * @{
 305:src/stm32f1xx_hal_pwr.c ****   */
 306:src/stm32f1xx_hal_pwr.c **** 
 307:src/stm32f1xx_hal_pwr.c **** /**
 308:src/stm32f1xx_hal_pwr.c ****   * @brief  Configures the voltage threshold detected by the Power Voltage Detector(PVD).
 309:src/stm32f1xx_hal_pwr.c ****   * @param  sConfigPVD: pointer to an PWR_PVDTypeDef structure that contains the configuration
 310:src/stm32f1xx_hal_pwr.c ****   *         information for the PVD.
 311:src/stm32f1xx_hal_pwr.c ****   * @note   Refer to the electrical characteristics of your device datasheet for
 312:src/stm32f1xx_hal_pwr.c ****   *         more details about the voltage threshold corresponding to each
 313:src/stm32f1xx_hal_pwr.c ****   *         detection level.
 314:src/stm32f1xx_hal_pwr.c ****   * @retval None
 315:src/stm32f1xx_hal_pwr.c ****   */
 316:src/stm32f1xx_hal_pwr.c **** void HAL_PWR_ConfigPVD(PWR_PVDTypeDef *sConfigPVD)
 317:src/stm32f1xx_hal_pwr.c **** {
 190              		.loc 1 317 0
 191              		.cfi_startproc
 192              		@ args = 0, pretend = 0, frame = 0
 193              		@ frame_needed = 0, uses_anonymous_args = 0
 194              		@ link register save eliminated.
 195              	.LVL0:
 318:src/stm32f1xx_hal_pwr.c ****   /* Check the parameters */
ARM GAS  /tmp/cciAnlD7.s 			page 10


 319:src/stm32f1xx_hal_pwr.c ****   assert_param(IS_PWR_PVD_LEVEL(sConfigPVD->PVDLevel));
 320:src/stm32f1xx_hal_pwr.c ****   assert_param(IS_PWR_PVD_MODE(sConfigPVD->Mode));
 321:src/stm32f1xx_hal_pwr.c **** 
 322:src/stm32f1xx_hal_pwr.c ****   /* Set PLS[7:5] bits according to PVDLevel value */
 323:src/stm32f1xx_hal_pwr.c ****   MODIFY_REG(PWR->CR, PWR_CR_PLS, sConfigPVD->PVDLevel);
 196              		.loc 1 323 0
 197 0038 184A     		ldr	r2, .L28	@ tmp136,
 198 003a 0168     		ldr	r1, [r0]	@ sConfigPVD_8(D)->PVDLevel, sConfigPVD_8(D)->PVDLevel
 199 003c 1368     		ldr	r3, [r2]	@ _6, MEM[(struct PWR_TypeDef *)1073770496B].CR
 200 003e 23F0E003 		bic	r3, r3, #224	@ tmp137, _6,
 201 0042 0B43     		orrs	r3, r3, r1	@, _10, tmp137, sConfigPVD_8(D)->PVDLevel
 202 0044 1360     		str	r3, [r2]	@ _10, MEM[(struct PWR_TypeDef *)1073770496B].CR
 324:src/stm32f1xx_hal_pwr.c ****   
 325:src/stm32f1xx_hal_pwr.c ****   /* Clear any previous config. Keep it clear if no event or IT mode is selected */
 326:src/stm32f1xx_hal_pwr.c ****   __HAL_PWR_PVD_EXTI_DISABLE_EVENT();
 203              		.loc 1 326 0
 204 0046 164B     		ldr	r3, .L28+4	@ tmp140,
 205 0048 5A68     		ldr	r2, [r3, #4]	@ _12, MEM[(struct EXTI_TypeDef *)1073808384B].EMR
 206 004a 22F48032 		bic	r2, r2, #65536	@ _13, _12,
 207 004e 5A60     		str	r2, [r3, #4]	@ _13, MEM[(struct EXTI_TypeDef *)1073808384B].EMR
 327:src/stm32f1xx_hal_pwr.c ****   __HAL_PWR_PVD_EXTI_DISABLE_IT();
 208              		.loc 1 327 0
 209 0050 1A68     		ldr	r2, [r3]	@ _15, MEM[(struct EXTI_TypeDef *)1073808384B].IMR
 210 0052 22F48032 		bic	r2, r2, #65536	@ _16, _15,
 211 0056 1A60     		str	r2, [r3]	@ _16, MEM[(struct EXTI_TypeDef *)1073808384B].IMR
 328:src/stm32f1xx_hal_pwr.c ****   __HAL_PWR_PVD_EXTI_DISABLE_FALLING_EDGE(); 
 212              		.loc 1 328 0
 213 0058 DA68     		ldr	r2, [r3, #12]	@ _18, MEM[(struct EXTI_TypeDef *)1073808384B].FTSR
 214 005a 22F48032 		bic	r2, r2, #65536	@ _19, _18,
 215 005e DA60     		str	r2, [r3, #12]	@ _19, MEM[(struct EXTI_TypeDef *)1073808384B].FTSR
 329:src/stm32f1xx_hal_pwr.c ****   __HAL_PWR_PVD_EXTI_DISABLE_RISING_EDGE();
 216              		.loc 1 329 0
 217 0060 9A68     		ldr	r2, [r3, #8]	@ _21, MEM[(struct EXTI_TypeDef *)1073808384B].RTSR
 218 0062 22F48032 		bic	r2, r2, #65536	@ _22, _21,
 219 0066 9A60     		str	r2, [r3, #8]	@ _22, MEM[(struct EXTI_TypeDef *)1073808384B].RTSR
 330:src/stm32f1xx_hal_pwr.c **** 
 331:src/stm32f1xx_hal_pwr.c ****   /* Configure interrupt mode */
 332:src/stm32f1xx_hal_pwr.c ****   if((sConfigPVD->Mode & PVD_MODE_IT) == PVD_MODE_IT)
 220              		.loc 1 332 0
 221 0068 4268     		ldr	r2, [r0, #4]	@ _24, sConfigPVD_8(D)->Mode
 222 006a D103     		lsls	r1, r2, #15	@, _24,
 333:src/stm32f1xx_hal_pwr.c ****   {
 334:src/stm32f1xx_hal_pwr.c ****     __HAL_PWR_PVD_EXTI_ENABLE_IT();
 223              		.loc 1 334 0
 224 006c 42BF     		ittt	mi
 225 006e 1968     		ldrmi	r1, [r3]	@ _26, MEM[(struct EXTI_TypeDef *)1073808384B].IMR
 226 0070 41F48031 		orrmi	r1, r1, #65536	@ _27, _26,
 227 0074 1960     		strmi	r1, [r3]	@ _27, MEM[(struct EXTI_TypeDef *)1073808384B].IMR
 335:src/stm32f1xx_hal_pwr.c ****   }
 336:src/stm32f1xx_hal_pwr.c ****   
 337:src/stm32f1xx_hal_pwr.c ****   /* Configure event mode */
 338:src/stm32f1xx_hal_pwr.c ****   if((sConfigPVD->Mode & PVD_MODE_EVT) == PVD_MODE_EVT)
 228              		.loc 1 338 0
 229 0076 9003     		lsls	r0, r2, #14	@, _24,
 230              	.LVL1:
 339:src/stm32f1xx_hal_pwr.c ****   {
 340:src/stm32f1xx_hal_pwr.c ****     __HAL_PWR_PVD_EXTI_ENABLE_EVENT();
ARM GAS  /tmp/cciAnlD7.s 			page 11


 231              		.loc 1 340 0
 232 0078 42BF     		ittt	mi
 233 007a 5968     		ldrmi	r1, [r3, #4]	@ _30, MEM[(struct EXTI_TypeDef *)1073808384B].EMR
 234 007c 41F48031 		orrmi	r1, r1, #65536	@ _31, _30,
 235 0080 5960     		strmi	r1, [r3, #4]	@ _31, MEM[(struct EXTI_TypeDef *)1073808384B].EMR
 341:src/stm32f1xx_hal_pwr.c ****   }
 342:src/stm32f1xx_hal_pwr.c ****   
 343:src/stm32f1xx_hal_pwr.c ****   /* Configure the edge */
 344:src/stm32f1xx_hal_pwr.c ****   if((sConfigPVD->Mode & PVD_RISING_EDGE) == PVD_RISING_EDGE)
 236              		.loc 1 344 0
 237 0082 D107     		lsls	r1, r2, #31	@, _24,
 345:src/stm32f1xx_hal_pwr.c ****   {
 346:src/stm32f1xx_hal_pwr.c ****     __HAL_PWR_PVD_EXTI_ENABLE_RISING_EDGE();
 238              		.loc 1 346 0
 239 0084 42BF     		ittt	mi
 240 0086 9968     		ldrmi	r1, [r3, #8]	@ _34, MEM[(struct EXTI_TypeDef *)1073808384B].RTSR
 241 0088 41F48031 		orrmi	r1, r1, #65536	@ _35, _34,
 242 008c 9960     		strmi	r1, [r3, #8]	@ _35, MEM[(struct EXTI_TypeDef *)1073808384B].RTSR
 347:src/stm32f1xx_hal_pwr.c ****   }
 348:src/stm32f1xx_hal_pwr.c ****   
 349:src/stm32f1xx_hal_pwr.c ****   if((sConfigPVD->Mode & PVD_FALLING_EDGE) == PVD_FALLING_EDGE)
 243              		.loc 1 349 0
 244 008e 9207     		lsls	r2, r2, #30	@, _24,
 350:src/stm32f1xx_hal_pwr.c ****   {
 351:src/stm32f1xx_hal_pwr.c ****     __HAL_PWR_PVD_EXTI_ENABLE_FALLING_EDGE();
 245              		.loc 1 351 0
 246 0090 42BF     		ittt	mi
 247 0092 DA68     		ldrmi	r2, [r3, #12]	@ _38, MEM[(struct EXTI_TypeDef *)1073808384B].FTSR
 248 0094 42F48032 		orrmi	r2, r2, #65536	@ _39, _38,
 249 0098 DA60     		strmi	r2, [r3, #12]	@ _39, MEM[(struct EXTI_TypeDef *)1073808384B].FTSR
 250 009a 7047     		bx	lr	@
 251              	.L29:
 252              		.align	2
 253              	.L28:
 254 009c 00700040 		.word	1073770496
 255 00a0 00040140 		.word	1073808384
 256              		.cfi_endproc
 257              	.LFE69:
 258              		.size	HAL_PWR_ConfigPVD, .-HAL_PWR_ConfigPVD
 259              		.align	1
 260              		.global	HAL_PWR_EnablePVD
 261              		.syntax unified
 262              		.thumb
 263              		.thumb_func
 264              		.fpu softvfp
 265              		.type	HAL_PWR_EnablePVD, %function
 266              	HAL_PWR_EnablePVD:
 267              	.LFB70:
 352:src/stm32f1xx_hal_pwr.c ****   }
 353:src/stm32f1xx_hal_pwr.c **** }
 354:src/stm32f1xx_hal_pwr.c **** 
 355:src/stm32f1xx_hal_pwr.c **** /**
 356:src/stm32f1xx_hal_pwr.c ****   * @brief  Enables the Power Voltage Detector(PVD).
 357:src/stm32f1xx_hal_pwr.c ****   * @retval None
 358:src/stm32f1xx_hal_pwr.c ****   */
 359:src/stm32f1xx_hal_pwr.c **** void HAL_PWR_EnablePVD(void)
 360:src/stm32f1xx_hal_pwr.c **** {
ARM GAS  /tmp/cciAnlD7.s 			page 12


 268              		.loc 1 360 0
 269              		.cfi_startproc
 270              		@ args = 0, pretend = 0, frame = 0
 271              		@ frame_needed = 0, uses_anonymous_args = 0
 272              		@ link register save eliminated.
 361:src/stm32f1xx_hal_pwr.c ****   /* Enable the power voltage detector */
 362:src/stm32f1xx_hal_pwr.c ****   *(__IO uint32_t *) CR_PVDE_BB = (uint32_t)ENABLE;
 273              		.loc 1 362 0
 274 00a4 0122     		movs	r2, #1	@ tmp111,
 275 00a6 014B     		ldr	r3, .L31	@ tmp110,
 276 00a8 1A60     		str	r2, [r3]	@ tmp111, MEM[(volatile uint32_t *)1108213776B]
 277 00aa 7047     		bx	lr	@
 278              	.L32:
 279              		.align	2
 280              	.L31:
 281 00ac 10000E42 		.word	1108213776
 282              		.cfi_endproc
 283              	.LFE70:
 284              		.size	HAL_PWR_EnablePVD, .-HAL_PWR_EnablePVD
 285              		.align	1
 286              		.global	HAL_PWR_DisablePVD
 287              		.syntax unified
 288              		.thumb
 289              		.thumb_func
 290              		.fpu softvfp
 291              		.type	HAL_PWR_DisablePVD, %function
 292              	HAL_PWR_DisablePVD:
 293              	.LFB71:
 363:src/stm32f1xx_hal_pwr.c **** }
 364:src/stm32f1xx_hal_pwr.c **** 
 365:src/stm32f1xx_hal_pwr.c **** /**
 366:src/stm32f1xx_hal_pwr.c ****   * @brief  Disables the Power Voltage Detector(PVD).
 367:src/stm32f1xx_hal_pwr.c ****   * @retval None
 368:src/stm32f1xx_hal_pwr.c ****   */
 369:src/stm32f1xx_hal_pwr.c **** void HAL_PWR_DisablePVD(void)
 370:src/stm32f1xx_hal_pwr.c **** {
 294              		.loc 1 370 0
 295              		.cfi_startproc
 296              		@ args = 0, pretend = 0, frame = 0
 297              		@ frame_needed = 0, uses_anonymous_args = 0
 298              		@ link register save eliminated.
 371:src/stm32f1xx_hal_pwr.c ****   /* Disable the power voltage detector */
 372:src/stm32f1xx_hal_pwr.c ****   *(__IO uint32_t *) CR_PVDE_BB = (uint32_t)DISABLE;
 299              		.loc 1 372 0
 300 00b0 0022     		movs	r2, #0	@ tmp111,
 301 00b2 014B     		ldr	r3, .L34	@ tmp110,
 302 00b4 1A60     		str	r2, [r3]	@ tmp111, MEM[(volatile uint32_t *)1108213776B]
 303 00b6 7047     		bx	lr	@
 304              	.L35:
 305              		.align	2
 306              	.L34:
 307 00b8 10000E42 		.word	1108213776
 308              		.cfi_endproc
 309              	.LFE71:
 310              		.size	HAL_PWR_DisablePVD, .-HAL_PWR_DisablePVD
 311              		.align	1
 312              		.global	HAL_PWR_EnableWakeUpPin
ARM GAS  /tmp/cciAnlD7.s 			page 13


 313              		.syntax unified
 314              		.thumb
 315              		.thumb_func
 316              		.fpu softvfp
 317              		.type	HAL_PWR_EnableWakeUpPin, %function
 318              	HAL_PWR_EnableWakeUpPin:
 319              	.LFB72:
 373:src/stm32f1xx_hal_pwr.c **** }
 374:src/stm32f1xx_hal_pwr.c **** 
 375:src/stm32f1xx_hal_pwr.c **** /**
 376:src/stm32f1xx_hal_pwr.c ****   * @brief Enables the WakeUp PINx functionality.
 377:src/stm32f1xx_hal_pwr.c ****   * @param WakeUpPinx: Specifies the Power Wake-Up pin to enable.
 378:src/stm32f1xx_hal_pwr.c ****   *        This parameter can be one of the following values:
 379:src/stm32f1xx_hal_pwr.c ****   *           @arg PWR_WAKEUP_PIN1
 380:src/stm32f1xx_hal_pwr.c ****   * @retval None
 381:src/stm32f1xx_hal_pwr.c ****   */
 382:src/stm32f1xx_hal_pwr.c **** void HAL_PWR_EnableWakeUpPin(uint32_t WakeUpPinx)
 383:src/stm32f1xx_hal_pwr.c **** {
 320              		.loc 1 383 0
 321              		.cfi_startproc
 322              		@ args = 0, pretend = 0, frame = 0
 323              		@ frame_needed = 0, uses_anonymous_args = 0
 324              		@ link register save eliminated.
 325              	.LVL2:
 326              	.LBB6:
 327              	.LBB7:
 328              		.file 2 "../cmsiscore/inc/cmsis_gcc.h"
   1:../cmsiscore/inc/cmsis_gcc.h **** /**************************************************************************//**
   2:../cmsiscore/inc/cmsis_gcc.h ****  * @file     cmsis_gcc.h
   3:../cmsiscore/inc/cmsis_gcc.h ****  * @brief    CMSIS compiler GCC header file
   4:../cmsiscore/inc/cmsis_gcc.h ****  * @version  V5.0.4
   5:../cmsiscore/inc/cmsis_gcc.h ****  * @date     09. April 2018
   6:../cmsiscore/inc/cmsis_gcc.h ****  ******************************************************************************/
   7:../cmsiscore/inc/cmsis_gcc.h **** /*
   8:../cmsiscore/inc/cmsis_gcc.h ****  * Copyright (c) 2009-2018 Arm Limited. All rights reserved.
   9:../cmsiscore/inc/cmsis_gcc.h ****  *
  10:../cmsiscore/inc/cmsis_gcc.h ****  * SPDX-License-Identifier: Apache-2.0
  11:../cmsiscore/inc/cmsis_gcc.h ****  *
  12:../cmsiscore/inc/cmsis_gcc.h ****  * Licensed under the Apache License, Version 2.0 (the License); you may
  13:../cmsiscore/inc/cmsis_gcc.h ****  * not use this file except in compliance with the License.
  14:../cmsiscore/inc/cmsis_gcc.h ****  * You may obtain a copy of the License at
  15:../cmsiscore/inc/cmsis_gcc.h ****  *
  16:../cmsiscore/inc/cmsis_gcc.h ****  * www.apache.org/licenses/LICENSE-2.0
  17:../cmsiscore/inc/cmsis_gcc.h ****  *
  18:../cmsiscore/inc/cmsis_gcc.h ****  * Unless required by applicable law or agreed to in writing, software
  19:../cmsiscore/inc/cmsis_gcc.h ****  * distributed under the License is distributed on an AS IS BASIS, WITHOUT
  20:../cmsiscore/inc/cmsis_gcc.h ****  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  21:../cmsiscore/inc/cmsis_gcc.h ****  * See the License for the specific language governing permissions and
  22:../cmsiscore/inc/cmsis_gcc.h ****  * limitations under the License.
  23:../cmsiscore/inc/cmsis_gcc.h ****  */
  24:../cmsiscore/inc/cmsis_gcc.h **** 
  25:../cmsiscore/inc/cmsis_gcc.h **** #ifndef __CMSIS_GCC_H
  26:../cmsiscore/inc/cmsis_gcc.h **** #define __CMSIS_GCC_H
  27:../cmsiscore/inc/cmsis_gcc.h **** 
  28:../cmsiscore/inc/cmsis_gcc.h **** /* ignore some GCC warnings */
  29:../cmsiscore/inc/cmsis_gcc.h **** #pragma GCC diagnostic push
  30:../cmsiscore/inc/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wsign-conversion"
ARM GAS  /tmp/cciAnlD7.s 			page 14


  31:../cmsiscore/inc/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wconversion"
  32:../cmsiscore/inc/cmsis_gcc.h **** #pragma GCC diagnostic ignored "-Wunused-parameter"
  33:../cmsiscore/inc/cmsis_gcc.h **** 
  34:../cmsiscore/inc/cmsis_gcc.h **** /* Fallback for __has_builtin */
  35:../cmsiscore/inc/cmsis_gcc.h **** #ifndef __has_builtin
  36:../cmsiscore/inc/cmsis_gcc.h ****   #define __has_builtin(x) (0)
  37:../cmsiscore/inc/cmsis_gcc.h **** #endif
  38:../cmsiscore/inc/cmsis_gcc.h **** 
  39:../cmsiscore/inc/cmsis_gcc.h **** /* CMSIS compiler specific defines */
  40:../cmsiscore/inc/cmsis_gcc.h **** #ifndef   __ASM
  41:../cmsiscore/inc/cmsis_gcc.h ****   #define __ASM                                  __asm
  42:../cmsiscore/inc/cmsis_gcc.h **** #endif
  43:../cmsiscore/inc/cmsis_gcc.h **** #ifndef   __INLINE
  44:../cmsiscore/inc/cmsis_gcc.h ****   #define __INLINE                               inline
  45:../cmsiscore/inc/cmsis_gcc.h **** #endif
  46:../cmsiscore/inc/cmsis_gcc.h **** #ifndef   __STATIC_INLINE
  47:../cmsiscore/inc/cmsis_gcc.h ****   #define __STATIC_INLINE                        static inline
  48:../cmsiscore/inc/cmsis_gcc.h **** #endif
  49:../cmsiscore/inc/cmsis_gcc.h **** #ifndef   __STATIC_FORCEINLINE                 
  50:../cmsiscore/inc/cmsis_gcc.h ****   #define __STATIC_FORCEINLINE                   __attribute__((always_inline)) static inline
  51:../cmsiscore/inc/cmsis_gcc.h **** #endif                                           
  52:../cmsiscore/inc/cmsis_gcc.h **** #ifndef   __NO_RETURN
  53:../cmsiscore/inc/cmsis_gcc.h ****   #define __NO_RETURN                            __attribute__((__noreturn__))
  54:../cmsiscore/inc/cmsis_gcc.h **** #endif
  55:../cmsiscore/inc/cmsis_gcc.h **** #ifndef   __USED
  56:../cmsiscore/inc/cmsis_gcc.h ****   #define __USED                                 __attribute__((used))
  57:../cmsiscore/inc/cmsis_gcc.h **** #endif
  58:../cmsiscore/inc/cmsis_gcc.h **** #ifndef   __WEAK
  59:../cmsiscore/inc/cmsis_gcc.h ****   #define __WEAK                                 __attribute__((weak))
  60:../cmsiscore/inc/cmsis_gcc.h **** #endif
  61:../cmsiscore/inc/cmsis_gcc.h **** #ifndef   __PACKED
  62:../cmsiscore/inc/cmsis_gcc.h ****   #define __PACKED                               __attribute__((packed, aligned(1)))
  63:../cmsiscore/inc/cmsis_gcc.h **** #endif
  64:../cmsiscore/inc/cmsis_gcc.h **** #ifndef   __PACKED_STRUCT
  65:../cmsiscore/inc/cmsis_gcc.h ****   #define __PACKED_STRUCT                        struct __attribute__((packed, aligned(1)))
  66:../cmsiscore/inc/cmsis_gcc.h **** #endif
  67:../cmsiscore/inc/cmsis_gcc.h **** #ifndef   __PACKED_UNION
  68:../cmsiscore/inc/cmsis_gcc.h ****   #define __PACKED_UNION                         union __attribute__((packed, aligned(1)))
  69:../cmsiscore/inc/cmsis_gcc.h **** #endif
  70:../cmsiscore/inc/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT32        /* deprecated */
  71:../cmsiscore/inc/cmsis_gcc.h ****   #pragma GCC diagnostic push
  72:../cmsiscore/inc/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  73:../cmsiscore/inc/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  74:../cmsiscore/inc/cmsis_gcc.h ****   struct __attribute__((packed)) T_UINT32 { uint32_t v; };
  75:../cmsiscore/inc/cmsis_gcc.h ****   #pragma GCC diagnostic pop
  76:../cmsiscore/inc/cmsis_gcc.h ****   #define __UNALIGNED_UINT32(x)                  (((struct T_UINT32 *)(x))->v)
  77:../cmsiscore/inc/cmsis_gcc.h **** #endif
  78:../cmsiscore/inc/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT16_WRITE
  79:../cmsiscore/inc/cmsis_gcc.h ****   #pragma GCC diagnostic push
  80:../cmsiscore/inc/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  81:../cmsiscore/inc/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  82:../cmsiscore/inc/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT16_WRITE { uint16_t v; };
  83:../cmsiscore/inc/cmsis_gcc.h ****   #pragma GCC diagnostic pop
  84:../cmsiscore/inc/cmsis_gcc.h ****   #define __UNALIGNED_UINT16_WRITE(addr, val)    (void)((((struct T_UINT16_WRITE *)(void *)(addr))-
  85:../cmsiscore/inc/cmsis_gcc.h **** #endif
  86:../cmsiscore/inc/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT16_READ
  87:../cmsiscore/inc/cmsis_gcc.h ****   #pragma GCC diagnostic push
ARM GAS  /tmp/cciAnlD7.s 			page 15


  88:../cmsiscore/inc/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  89:../cmsiscore/inc/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  90:../cmsiscore/inc/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT16_READ { uint16_t v; };
  91:../cmsiscore/inc/cmsis_gcc.h ****   #pragma GCC diagnostic pop
  92:../cmsiscore/inc/cmsis_gcc.h ****   #define __UNALIGNED_UINT16_READ(addr)          (((const struct T_UINT16_READ *)(const void *)(add
  93:../cmsiscore/inc/cmsis_gcc.h **** #endif
  94:../cmsiscore/inc/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT32_WRITE
  95:../cmsiscore/inc/cmsis_gcc.h ****   #pragma GCC diagnostic push
  96:../cmsiscore/inc/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
  97:../cmsiscore/inc/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
  98:../cmsiscore/inc/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT32_WRITE { uint32_t v; };
  99:../cmsiscore/inc/cmsis_gcc.h ****   #pragma GCC diagnostic pop
 100:../cmsiscore/inc/cmsis_gcc.h ****   #define __UNALIGNED_UINT32_WRITE(addr, val)    (void)((((struct T_UINT32_WRITE *)(void *)(addr))-
 101:../cmsiscore/inc/cmsis_gcc.h **** #endif
 102:../cmsiscore/inc/cmsis_gcc.h **** #ifndef   __UNALIGNED_UINT32_READ
 103:../cmsiscore/inc/cmsis_gcc.h ****   #pragma GCC diagnostic push
 104:../cmsiscore/inc/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wpacked"
 105:../cmsiscore/inc/cmsis_gcc.h ****   #pragma GCC diagnostic ignored "-Wattributes"
 106:../cmsiscore/inc/cmsis_gcc.h ****   __PACKED_STRUCT T_UINT32_READ { uint32_t v; };
 107:../cmsiscore/inc/cmsis_gcc.h ****   #pragma GCC diagnostic pop
 108:../cmsiscore/inc/cmsis_gcc.h ****   #define __UNALIGNED_UINT32_READ(addr)          (((const struct T_UINT32_READ *)(const void *)(add
 109:../cmsiscore/inc/cmsis_gcc.h **** #endif
 110:../cmsiscore/inc/cmsis_gcc.h **** #ifndef   __ALIGNED
 111:../cmsiscore/inc/cmsis_gcc.h ****   #define __ALIGNED(x)                           __attribute__((aligned(x)))
 112:../cmsiscore/inc/cmsis_gcc.h **** #endif
 113:../cmsiscore/inc/cmsis_gcc.h **** #ifndef   __RESTRICT
 114:../cmsiscore/inc/cmsis_gcc.h ****   #define __RESTRICT                             __restrict
 115:../cmsiscore/inc/cmsis_gcc.h **** #endif
 116:../cmsiscore/inc/cmsis_gcc.h **** 
 117:../cmsiscore/inc/cmsis_gcc.h **** 
 118:../cmsiscore/inc/cmsis_gcc.h **** /* ###########################  Core Function Access  ########################### */
 119:../cmsiscore/inc/cmsis_gcc.h **** /** \ingroup  CMSIS_Core_FunctionInterface
 120:../cmsiscore/inc/cmsis_gcc.h ****     \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
 121:../cmsiscore/inc/cmsis_gcc.h ****   @{
 122:../cmsiscore/inc/cmsis_gcc.h ****  */
 123:../cmsiscore/inc/cmsis_gcc.h **** 
 124:../cmsiscore/inc/cmsis_gcc.h **** /**
 125:../cmsiscore/inc/cmsis_gcc.h ****   \brief   Enable IRQ Interrupts
 126:../cmsiscore/inc/cmsis_gcc.h ****   \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
 127:../cmsiscore/inc/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 128:../cmsiscore/inc/cmsis_gcc.h ****  */
 129:../cmsiscore/inc/cmsis_gcc.h **** __STATIC_FORCEINLINE void __enable_irq(void)
 130:../cmsiscore/inc/cmsis_gcc.h **** {
 131:../cmsiscore/inc/cmsis_gcc.h ****   __ASM volatile ("cpsie i" : : : "memory");
 132:../cmsiscore/inc/cmsis_gcc.h **** }
 133:../cmsiscore/inc/cmsis_gcc.h **** 
 134:../cmsiscore/inc/cmsis_gcc.h **** 
 135:../cmsiscore/inc/cmsis_gcc.h **** /**
 136:../cmsiscore/inc/cmsis_gcc.h ****   \brief   Disable IRQ Interrupts
 137:../cmsiscore/inc/cmsis_gcc.h ****   \details Disables IRQ interrupts by setting the I-bit in the CPSR.
 138:../cmsiscore/inc/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 139:../cmsiscore/inc/cmsis_gcc.h ****  */
 140:../cmsiscore/inc/cmsis_gcc.h **** __STATIC_FORCEINLINE void __disable_irq(void)
 141:../cmsiscore/inc/cmsis_gcc.h **** {
 142:../cmsiscore/inc/cmsis_gcc.h ****   __ASM volatile ("cpsid i" : : : "memory");
 143:../cmsiscore/inc/cmsis_gcc.h **** }
 144:../cmsiscore/inc/cmsis_gcc.h **** 
ARM GAS  /tmp/cciAnlD7.s 			page 16


 145:../cmsiscore/inc/cmsis_gcc.h **** 
 146:../cmsiscore/inc/cmsis_gcc.h **** /**
 147:../cmsiscore/inc/cmsis_gcc.h ****   \brief   Get Control Register
 148:../cmsiscore/inc/cmsis_gcc.h ****   \details Returns the content of the Control Register.
 149:../cmsiscore/inc/cmsis_gcc.h ****   \return               Control Register value
 150:../cmsiscore/inc/cmsis_gcc.h ****  */
 151:../cmsiscore/inc/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_CONTROL(void)
 152:../cmsiscore/inc/cmsis_gcc.h **** {
 153:../cmsiscore/inc/cmsis_gcc.h ****   uint32_t result;
 154:../cmsiscore/inc/cmsis_gcc.h **** 
 155:../cmsiscore/inc/cmsis_gcc.h ****   __ASM volatile ("MRS %0, control" : "=r" (result) );
 156:../cmsiscore/inc/cmsis_gcc.h ****   return(result);
 157:../cmsiscore/inc/cmsis_gcc.h **** }
 158:../cmsiscore/inc/cmsis_gcc.h **** 
 159:../cmsiscore/inc/cmsis_gcc.h **** 
 160:../cmsiscore/inc/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 161:../cmsiscore/inc/cmsis_gcc.h **** /**
 162:../cmsiscore/inc/cmsis_gcc.h ****   \brief   Get Control Register (non-secure)
 163:../cmsiscore/inc/cmsis_gcc.h ****   \details Returns the content of the non-secure Control Register when in secure mode.
 164:../cmsiscore/inc/cmsis_gcc.h ****   \return               non-secure Control Register value
 165:../cmsiscore/inc/cmsis_gcc.h ****  */
 166:../cmsiscore/inc/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_CONTROL_NS(void)
 167:../cmsiscore/inc/cmsis_gcc.h **** {
 168:../cmsiscore/inc/cmsis_gcc.h ****   uint32_t result;
 169:../cmsiscore/inc/cmsis_gcc.h **** 
 170:../cmsiscore/inc/cmsis_gcc.h ****   __ASM volatile ("MRS %0, control_ns" : "=r" (result) );
 171:../cmsiscore/inc/cmsis_gcc.h ****   return(result);
 172:../cmsiscore/inc/cmsis_gcc.h **** }
 173:../cmsiscore/inc/cmsis_gcc.h **** #endif
 174:../cmsiscore/inc/cmsis_gcc.h **** 
 175:../cmsiscore/inc/cmsis_gcc.h **** 
 176:../cmsiscore/inc/cmsis_gcc.h **** /**
 177:../cmsiscore/inc/cmsis_gcc.h ****   \brief   Set Control Register
 178:../cmsiscore/inc/cmsis_gcc.h ****   \details Writes the given value to the Control Register.
 179:../cmsiscore/inc/cmsis_gcc.h ****   \param [in]    control  Control Register value to set
 180:../cmsiscore/inc/cmsis_gcc.h ****  */
 181:../cmsiscore/inc/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_CONTROL(uint32_t control)
 182:../cmsiscore/inc/cmsis_gcc.h **** {
 183:../cmsiscore/inc/cmsis_gcc.h ****   __ASM volatile ("MSR control, %0" : : "r" (control) : "memory");
 184:../cmsiscore/inc/cmsis_gcc.h **** }
 185:../cmsiscore/inc/cmsis_gcc.h **** 
 186:../cmsiscore/inc/cmsis_gcc.h **** 
 187:../cmsiscore/inc/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 188:../cmsiscore/inc/cmsis_gcc.h **** /**
 189:../cmsiscore/inc/cmsis_gcc.h ****   \brief   Set Control Register (non-secure)
 190:../cmsiscore/inc/cmsis_gcc.h ****   \details Writes the given value to the non-secure Control Register when in secure state.
 191:../cmsiscore/inc/cmsis_gcc.h ****   \param [in]    control  Control Register value to set
 192:../cmsiscore/inc/cmsis_gcc.h ****  */
 193:../cmsiscore/inc/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_CONTROL_NS(uint32_t control)
 194:../cmsiscore/inc/cmsis_gcc.h **** {
 195:../cmsiscore/inc/cmsis_gcc.h ****   __ASM volatile ("MSR control_ns, %0" : : "r" (control) : "memory");
 196:../cmsiscore/inc/cmsis_gcc.h **** }
 197:../cmsiscore/inc/cmsis_gcc.h **** #endif
 198:../cmsiscore/inc/cmsis_gcc.h **** 
 199:../cmsiscore/inc/cmsis_gcc.h **** 
 200:../cmsiscore/inc/cmsis_gcc.h **** /**
 201:../cmsiscore/inc/cmsis_gcc.h ****   \brief   Get IPSR Register
ARM GAS  /tmp/cciAnlD7.s 			page 17


 202:../cmsiscore/inc/cmsis_gcc.h ****   \details Returns the content of the IPSR Register.
 203:../cmsiscore/inc/cmsis_gcc.h ****   \return               IPSR Register value
 204:../cmsiscore/inc/cmsis_gcc.h ****  */
 205:../cmsiscore/inc/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_IPSR(void)
 206:../cmsiscore/inc/cmsis_gcc.h **** {
 207:../cmsiscore/inc/cmsis_gcc.h ****   uint32_t result;
 208:../cmsiscore/inc/cmsis_gcc.h **** 
 209:../cmsiscore/inc/cmsis_gcc.h ****   __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 210:../cmsiscore/inc/cmsis_gcc.h ****   return(result);
 211:../cmsiscore/inc/cmsis_gcc.h **** }
 212:../cmsiscore/inc/cmsis_gcc.h **** 
 213:../cmsiscore/inc/cmsis_gcc.h **** 
 214:../cmsiscore/inc/cmsis_gcc.h **** /**
 215:../cmsiscore/inc/cmsis_gcc.h ****   \brief   Get APSR Register
 216:../cmsiscore/inc/cmsis_gcc.h ****   \details Returns the content of the APSR Register.
 217:../cmsiscore/inc/cmsis_gcc.h ****   \return               APSR Register value
 218:../cmsiscore/inc/cmsis_gcc.h ****  */
 219:../cmsiscore/inc/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_APSR(void)
 220:../cmsiscore/inc/cmsis_gcc.h **** {
 221:../cmsiscore/inc/cmsis_gcc.h ****   uint32_t result;
 222:../cmsiscore/inc/cmsis_gcc.h **** 
 223:../cmsiscore/inc/cmsis_gcc.h ****   __ASM volatile ("MRS %0, apsr" : "=r" (result) );
 224:../cmsiscore/inc/cmsis_gcc.h ****   return(result);
 225:../cmsiscore/inc/cmsis_gcc.h **** }
 226:../cmsiscore/inc/cmsis_gcc.h **** 
 227:../cmsiscore/inc/cmsis_gcc.h **** 
 228:../cmsiscore/inc/cmsis_gcc.h **** /**
 229:../cmsiscore/inc/cmsis_gcc.h ****   \brief   Get xPSR Register
 230:../cmsiscore/inc/cmsis_gcc.h ****   \details Returns the content of the xPSR Register.
 231:../cmsiscore/inc/cmsis_gcc.h ****   \return               xPSR Register value
 232:../cmsiscore/inc/cmsis_gcc.h ****  */
 233:../cmsiscore/inc/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_xPSR(void)
 234:../cmsiscore/inc/cmsis_gcc.h **** {
 235:../cmsiscore/inc/cmsis_gcc.h ****   uint32_t result;
 236:../cmsiscore/inc/cmsis_gcc.h **** 
 237:../cmsiscore/inc/cmsis_gcc.h ****   __ASM volatile ("MRS %0, xpsr" : "=r" (result) );
 238:../cmsiscore/inc/cmsis_gcc.h ****   return(result);
 239:../cmsiscore/inc/cmsis_gcc.h **** }
 240:../cmsiscore/inc/cmsis_gcc.h **** 
 241:../cmsiscore/inc/cmsis_gcc.h **** 
 242:../cmsiscore/inc/cmsis_gcc.h **** /**
 243:../cmsiscore/inc/cmsis_gcc.h ****   \brief   Get Process Stack Pointer
 244:../cmsiscore/inc/cmsis_gcc.h ****   \details Returns the current value of the Process Stack Pointer (PSP).
 245:../cmsiscore/inc/cmsis_gcc.h ****   \return               PSP Register value
 246:../cmsiscore/inc/cmsis_gcc.h ****  */
 247:../cmsiscore/inc/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_PSP(void)
 248:../cmsiscore/inc/cmsis_gcc.h **** {
 249:../cmsiscore/inc/cmsis_gcc.h ****   uint32_t result;
 250:../cmsiscore/inc/cmsis_gcc.h **** 
 251:../cmsiscore/inc/cmsis_gcc.h ****   __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 252:../cmsiscore/inc/cmsis_gcc.h ****   return(result);
 253:../cmsiscore/inc/cmsis_gcc.h **** }
 254:../cmsiscore/inc/cmsis_gcc.h **** 
 255:../cmsiscore/inc/cmsis_gcc.h **** 
 256:../cmsiscore/inc/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 257:../cmsiscore/inc/cmsis_gcc.h **** /**
 258:../cmsiscore/inc/cmsis_gcc.h ****   \brief   Get Process Stack Pointer (non-secure)
ARM GAS  /tmp/cciAnlD7.s 			page 18


 259:../cmsiscore/inc/cmsis_gcc.h ****   \details Returns the current value of the non-secure Process Stack Pointer (PSP) when in secure s
 260:../cmsiscore/inc/cmsis_gcc.h ****   \return               PSP Register value
 261:../cmsiscore/inc/cmsis_gcc.h ****  */
 262:../cmsiscore/inc/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_PSP_NS(void)
 263:../cmsiscore/inc/cmsis_gcc.h **** {
 264:../cmsiscore/inc/cmsis_gcc.h ****   uint32_t result;
 265:../cmsiscore/inc/cmsis_gcc.h **** 
 266:../cmsiscore/inc/cmsis_gcc.h ****   __ASM volatile ("MRS %0, psp_ns"  : "=r" (result) );
 267:../cmsiscore/inc/cmsis_gcc.h ****   return(result);
 268:../cmsiscore/inc/cmsis_gcc.h **** }
 269:../cmsiscore/inc/cmsis_gcc.h **** #endif
 270:../cmsiscore/inc/cmsis_gcc.h **** 
 271:../cmsiscore/inc/cmsis_gcc.h **** 
 272:../cmsiscore/inc/cmsis_gcc.h **** /**
 273:../cmsiscore/inc/cmsis_gcc.h ****   \brief   Set Process Stack Pointer
 274:../cmsiscore/inc/cmsis_gcc.h ****   \details Assigns the given value to the Process Stack Pointer (PSP).
 275:../cmsiscore/inc/cmsis_gcc.h ****   \param [in]    topOfProcStack  Process Stack Pointer value to set
 276:../cmsiscore/inc/cmsis_gcc.h ****  */
 277:../cmsiscore/inc/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_PSP(uint32_t topOfProcStack)
 278:../cmsiscore/inc/cmsis_gcc.h **** {
 279:../cmsiscore/inc/cmsis_gcc.h ****   __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 280:../cmsiscore/inc/cmsis_gcc.h **** }
 281:../cmsiscore/inc/cmsis_gcc.h **** 
 282:../cmsiscore/inc/cmsis_gcc.h **** 
 283:../cmsiscore/inc/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 284:../cmsiscore/inc/cmsis_gcc.h **** /**
 285:../cmsiscore/inc/cmsis_gcc.h ****   \brief   Set Process Stack Pointer (non-secure)
 286:../cmsiscore/inc/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Process Stack Pointer (PSP) when in secure sta
 287:../cmsiscore/inc/cmsis_gcc.h ****   \param [in]    topOfProcStack  Process Stack Pointer value to set
 288:../cmsiscore/inc/cmsis_gcc.h ****  */
 289:../cmsiscore/inc/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_PSP_NS(uint32_t topOfProcStack)
 290:../cmsiscore/inc/cmsis_gcc.h **** {
 291:../cmsiscore/inc/cmsis_gcc.h ****   __ASM volatile ("MSR psp_ns, %0" : : "r" (topOfProcStack) : );
 292:../cmsiscore/inc/cmsis_gcc.h **** }
 293:../cmsiscore/inc/cmsis_gcc.h **** #endif
 294:../cmsiscore/inc/cmsis_gcc.h **** 
 295:../cmsiscore/inc/cmsis_gcc.h **** 
 296:../cmsiscore/inc/cmsis_gcc.h **** /**
 297:../cmsiscore/inc/cmsis_gcc.h ****   \brief   Get Main Stack Pointer
 298:../cmsiscore/inc/cmsis_gcc.h ****   \details Returns the current value of the Main Stack Pointer (MSP).
 299:../cmsiscore/inc/cmsis_gcc.h ****   \return               MSP Register value
 300:../cmsiscore/inc/cmsis_gcc.h ****  */
 301:../cmsiscore/inc/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_MSP(void)
 302:../cmsiscore/inc/cmsis_gcc.h **** {
 303:../cmsiscore/inc/cmsis_gcc.h ****   uint32_t result;
 304:../cmsiscore/inc/cmsis_gcc.h **** 
 305:../cmsiscore/inc/cmsis_gcc.h ****   __ASM volatile ("MRS %0, msp" : "=r" (result) );
 306:../cmsiscore/inc/cmsis_gcc.h ****   return(result);
 307:../cmsiscore/inc/cmsis_gcc.h **** }
 308:../cmsiscore/inc/cmsis_gcc.h **** 
 309:../cmsiscore/inc/cmsis_gcc.h **** 
 310:../cmsiscore/inc/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 311:../cmsiscore/inc/cmsis_gcc.h **** /**
 312:../cmsiscore/inc/cmsis_gcc.h ****   \brief   Get Main Stack Pointer (non-secure)
 313:../cmsiscore/inc/cmsis_gcc.h ****   \details Returns the current value of the non-secure Main Stack Pointer (MSP) when in secure stat
 314:../cmsiscore/inc/cmsis_gcc.h ****   \return               MSP Register value
 315:../cmsiscore/inc/cmsis_gcc.h ****  */
ARM GAS  /tmp/cciAnlD7.s 			page 19


 316:../cmsiscore/inc/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_MSP_NS(void)
 317:../cmsiscore/inc/cmsis_gcc.h **** {
 318:../cmsiscore/inc/cmsis_gcc.h ****   uint32_t result;
 319:../cmsiscore/inc/cmsis_gcc.h **** 
 320:../cmsiscore/inc/cmsis_gcc.h ****   __ASM volatile ("MRS %0, msp_ns" : "=r" (result) );
 321:../cmsiscore/inc/cmsis_gcc.h ****   return(result);
 322:../cmsiscore/inc/cmsis_gcc.h **** }
 323:../cmsiscore/inc/cmsis_gcc.h **** #endif
 324:../cmsiscore/inc/cmsis_gcc.h **** 
 325:../cmsiscore/inc/cmsis_gcc.h **** 
 326:../cmsiscore/inc/cmsis_gcc.h **** /**
 327:../cmsiscore/inc/cmsis_gcc.h ****   \brief   Set Main Stack Pointer
 328:../cmsiscore/inc/cmsis_gcc.h ****   \details Assigns the given value to the Main Stack Pointer (MSP).
 329:../cmsiscore/inc/cmsis_gcc.h ****   \param [in]    topOfMainStack  Main Stack Pointer value to set
 330:../cmsiscore/inc/cmsis_gcc.h ****  */
 331:../cmsiscore/inc/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_MSP(uint32_t topOfMainStack)
 332:../cmsiscore/inc/cmsis_gcc.h **** {
 333:../cmsiscore/inc/cmsis_gcc.h ****   __ASM volatile ("MSR msp, %0" : : "r" (topOfMainStack) : );
 334:../cmsiscore/inc/cmsis_gcc.h **** }
 335:../cmsiscore/inc/cmsis_gcc.h **** 
 336:../cmsiscore/inc/cmsis_gcc.h **** 
 337:../cmsiscore/inc/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 338:../cmsiscore/inc/cmsis_gcc.h **** /**
 339:../cmsiscore/inc/cmsis_gcc.h ****   \brief   Set Main Stack Pointer (non-secure)
 340:../cmsiscore/inc/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Main Stack Pointer (MSP) when in secure state.
 341:../cmsiscore/inc/cmsis_gcc.h ****   \param [in]    topOfMainStack  Main Stack Pointer value to set
 342:../cmsiscore/inc/cmsis_gcc.h ****  */
 343:../cmsiscore/inc/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_MSP_NS(uint32_t topOfMainStack)
 344:../cmsiscore/inc/cmsis_gcc.h **** {
 345:../cmsiscore/inc/cmsis_gcc.h ****   __ASM volatile ("MSR msp_ns, %0" : : "r" (topOfMainStack) : );
 346:../cmsiscore/inc/cmsis_gcc.h **** }
 347:../cmsiscore/inc/cmsis_gcc.h **** #endif
 348:../cmsiscore/inc/cmsis_gcc.h **** 
 349:../cmsiscore/inc/cmsis_gcc.h **** 
 350:../cmsiscore/inc/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 351:../cmsiscore/inc/cmsis_gcc.h **** /**
 352:../cmsiscore/inc/cmsis_gcc.h ****   \brief   Get Stack Pointer (non-secure)
 353:../cmsiscore/inc/cmsis_gcc.h ****   \details Returns the current value of the non-secure Stack Pointer (SP) when in secure state.
 354:../cmsiscore/inc/cmsis_gcc.h ****   \return               SP Register value
 355:../cmsiscore/inc/cmsis_gcc.h ****  */
 356:../cmsiscore/inc/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_SP_NS(void)
 357:../cmsiscore/inc/cmsis_gcc.h **** {
 358:../cmsiscore/inc/cmsis_gcc.h ****   uint32_t result;
 359:../cmsiscore/inc/cmsis_gcc.h **** 
 360:../cmsiscore/inc/cmsis_gcc.h ****   __ASM volatile ("MRS %0, sp_ns" : "=r" (result) );
 361:../cmsiscore/inc/cmsis_gcc.h ****   return(result);
 362:../cmsiscore/inc/cmsis_gcc.h **** }
 363:../cmsiscore/inc/cmsis_gcc.h **** 
 364:../cmsiscore/inc/cmsis_gcc.h **** 
 365:../cmsiscore/inc/cmsis_gcc.h **** /**
 366:../cmsiscore/inc/cmsis_gcc.h ****   \brief   Set Stack Pointer (non-secure)
 367:../cmsiscore/inc/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Stack Pointer (SP) when in secure state.
 368:../cmsiscore/inc/cmsis_gcc.h ****   \param [in]    topOfStack  Stack Pointer value to set
 369:../cmsiscore/inc/cmsis_gcc.h ****  */
 370:../cmsiscore/inc/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_SP_NS(uint32_t topOfStack)
 371:../cmsiscore/inc/cmsis_gcc.h **** {
 372:../cmsiscore/inc/cmsis_gcc.h ****   __ASM volatile ("MSR sp_ns, %0" : : "r" (topOfStack) : );
ARM GAS  /tmp/cciAnlD7.s 			page 20


 373:../cmsiscore/inc/cmsis_gcc.h **** }
 374:../cmsiscore/inc/cmsis_gcc.h **** #endif
 375:../cmsiscore/inc/cmsis_gcc.h **** 
 376:../cmsiscore/inc/cmsis_gcc.h **** 
 377:../cmsiscore/inc/cmsis_gcc.h **** /**
 378:../cmsiscore/inc/cmsis_gcc.h ****   \brief   Get Priority Mask
 379:../cmsiscore/inc/cmsis_gcc.h ****   \details Returns the current state of the priority mask bit from the Priority Mask Register.
 380:../cmsiscore/inc/cmsis_gcc.h ****   \return               Priority Mask value
 381:../cmsiscore/inc/cmsis_gcc.h ****  */
 382:../cmsiscore/inc/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_PRIMASK(void)
 383:../cmsiscore/inc/cmsis_gcc.h **** {
 384:../cmsiscore/inc/cmsis_gcc.h ****   uint32_t result;
 385:../cmsiscore/inc/cmsis_gcc.h **** 
 386:../cmsiscore/inc/cmsis_gcc.h ****   __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 387:../cmsiscore/inc/cmsis_gcc.h ****   return(result);
 388:../cmsiscore/inc/cmsis_gcc.h **** }
 389:../cmsiscore/inc/cmsis_gcc.h **** 
 390:../cmsiscore/inc/cmsis_gcc.h **** 
 391:../cmsiscore/inc/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 392:../cmsiscore/inc/cmsis_gcc.h **** /**
 393:../cmsiscore/inc/cmsis_gcc.h ****   \brief   Get Priority Mask (non-secure)
 394:../cmsiscore/inc/cmsis_gcc.h ****   \details Returns the current state of the non-secure priority mask bit from the Priority Mask Reg
 395:../cmsiscore/inc/cmsis_gcc.h ****   \return               Priority Mask value
 396:../cmsiscore/inc/cmsis_gcc.h ****  */
 397:../cmsiscore/inc/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_PRIMASK_NS(void)
 398:../cmsiscore/inc/cmsis_gcc.h **** {
 399:../cmsiscore/inc/cmsis_gcc.h ****   uint32_t result;
 400:../cmsiscore/inc/cmsis_gcc.h **** 
 401:../cmsiscore/inc/cmsis_gcc.h ****   __ASM volatile ("MRS %0, primask_ns" : "=r" (result) :: "memory");
 402:../cmsiscore/inc/cmsis_gcc.h ****   return(result);
 403:../cmsiscore/inc/cmsis_gcc.h **** }
 404:../cmsiscore/inc/cmsis_gcc.h **** #endif
 405:../cmsiscore/inc/cmsis_gcc.h **** 
 406:../cmsiscore/inc/cmsis_gcc.h **** 
 407:../cmsiscore/inc/cmsis_gcc.h **** /**
 408:../cmsiscore/inc/cmsis_gcc.h ****   \brief   Set Priority Mask
 409:../cmsiscore/inc/cmsis_gcc.h ****   \details Assigns the given value to the Priority Mask Register.
 410:../cmsiscore/inc/cmsis_gcc.h ****   \param [in]    priMask  Priority Mask
 411:../cmsiscore/inc/cmsis_gcc.h ****  */
 412:../cmsiscore/inc/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_PRIMASK(uint32_t priMask)
 413:../cmsiscore/inc/cmsis_gcc.h **** {
 414:../cmsiscore/inc/cmsis_gcc.h ****   __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 415:../cmsiscore/inc/cmsis_gcc.h **** }
 416:../cmsiscore/inc/cmsis_gcc.h **** 
 417:../cmsiscore/inc/cmsis_gcc.h **** 
 418:../cmsiscore/inc/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 419:../cmsiscore/inc/cmsis_gcc.h **** /**
 420:../cmsiscore/inc/cmsis_gcc.h ****   \brief   Set Priority Mask (non-secure)
 421:../cmsiscore/inc/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Priority Mask Register when in secure state.
 422:../cmsiscore/inc/cmsis_gcc.h ****   \param [in]    priMask  Priority Mask
 423:../cmsiscore/inc/cmsis_gcc.h ****  */
 424:../cmsiscore/inc/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_PRIMASK_NS(uint32_t priMask)
 425:../cmsiscore/inc/cmsis_gcc.h **** {
 426:../cmsiscore/inc/cmsis_gcc.h ****   __ASM volatile ("MSR primask_ns, %0" : : "r" (priMask) : "memory");
 427:../cmsiscore/inc/cmsis_gcc.h **** }
 428:../cmsiscore/inc/cmsis_gcc.h **** #endif
 429:../cmsiscore/inc/cmsis_gcc.h **** 
ARM GAS  /tmp/cciAnlD7.s 			page 21


 430:../cmsiscore/inc/cmsis_gcc.h **** 
 431:../cmsiscore/inc/cmsis_gcc.h **** #if ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
 432:../cmsiscore/inc/cmsis_gcc.h ****      (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
 433:../cmsiscore/inc/cmsis_gcc.h ****      (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    )
 434:../cmsiscore/inc/cmsis_gcc.h **** /**
 435:../cmsiscore/inc/cmsis_gcc.h ****   \brief   Enable FIQ
 436:../cmsiscore/inc/cmsis_gcc.h ****   \details Enables FIQ interrupts by clearing the F-bit in the CPSR.
 437:../cmsiscore/inc/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 438:../cmsiscore/inc/cmsis_gcc.h ****  */
 439:../cmsiscore/inc/cmsis_gcc.h **** __STATIC_FORCEINLINE void __enable_fault_irq(void)
 440:../cmsiscore/inc/cmsis_gcc.h **** {
 441:../cmsiscore/inc/cmsis_gcc.h ****   __ASM volatile ("cpsie f" : : : "memory");
 442:../cmsiscore/inc/cmsis_gcc.h **** }
 443:../cmsiscore/inc/cmsis_gcc.h **** 
 444:../cmsiscore/inc/cmsis_gcc.h **** 
 445:../cmsiscore/inc/cmsis_gcc.h **** /**
 446:../cmsiscore/inc/cmsis_gcc.h ****   \brief   Disable FIQ
 447:../cmsiscore/inc/cmsis_gcc.h ****   \details Disables FIQ interrupts by setting the F-bit in the CPSR.
 448:../cmsiscore/inc/cmsis_gcc.h ****            Can only be executed in Privileged modes.
 449:../cmsiscore/inc/cmsis_gcc.h ****  */
 450:../cmsiscore/inc/cmsis_gcc.h **** __STATIC_FORCEINLINE void __disable_fault_irq(void)
 451:../cmsiscore/inc/cmsis_gcc.h **** {
 452:../cmsiscore/inc/cmsis_gcc.h ****   __ASM volatile ("cpsid f" : : : "memory");
 453:../cmsiscore/inc/cmsis_gcc.h **** }
 454:../cmsiscore/inc/cmsis_gcc.h **** 
 455:../cmsiscore/inc/cmsis_gcc.h **** 
 456:../cmsiscore/inc/cmsis_gcc.h **** /**
 457:../cmsiscore/inc/cmsis_gcc.h ****   \brief   Get Base Priority
 458:../cmsiscore/inc/cmsis_gcc.h ****   \details Returns the current value of the Base Priority register.
 459:../cmsiscore/inc/cmsis_gcc.h ****   \return               Base Priority register value
 460:../cmsiscore/inc/cmsis_gcc.h ****  */
 461:../cmsiscore/inc/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_BASEPRI(void)
 462:../cmsiscore/inc/cmsis_gcc.h **** {
 463:../cmsiscore/inc/cmsis_gcc.h ****   uint32_t result;
 464:../cmsiscore/inc/cmsis_gcc.h **** 
 465:../cmsiscore/inc/cmsis_gcc.h ****   __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 466:../cmsiscore/inc/cmsis_gcc.h ****   return(result);
 467:../cmsiscore/inc/cmsis_gcc.h **** }
 468:../cmsiscore/inc/cmsis_gcc.h **** 
 469:../cmsiscore/inc/cmsis_gcc.h **** 
 470:../cmsiscore/inc/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 471:../cmsiscore/inc/cmsis_gcc.h **** /**
 472:../cmsiscore/inc/cmsis_gcc.h ****   \brief   Get Base Priority (non-secure)
 473:../cmsiscore/inc/cmsis_gcc.h ****   \details Returns the current value of the non-secure Base Priority register when in secure state.
 474:../cmsiscore/inc/cmsis_gcc.h ****   \return               Base Priority register value
 475:../cmsiscore/inc/cmsis_gcc.h ****  */
 476:../cmsiscore/inc/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_BASEPRI_NS(void)
 477:../cmsiscore/inc/cmsis_gcc.h **** {
 478:../cmsiscore/inc/cmsis_gcc.h ****   uint32_t result;
 479:../cmsiscore/inc/cmsis_gcc.h **** 
 480:../cmsiscore/inc/cmsis_gcc.h ****   __ASM volatile ("MRS %0, basepri_ns" : "=r" (result) );
 481:../cmsiscore/inc/cmsis_gcc.h ****   return(result);
 482:../cmsiscore/inc/cmsis_gcc.h **** }
 483:../cmsiscore/inc/cmsis_gcc.h **** #endif
 484:../cmsiscore/inc/cmsis_gcc.h **** 
 485:../cmsiscore/inc/cmsis_gcc.h **** 
 486:../cmsiscore/inc/cmsis_gcc.h **** /**
ARM GAS  /tmp/cciAnlD7.s 			page 22


 487:../cmsiscore/inc/cmsis_gcc.h ****   \brief   Set Base Priority
 488:../cmsiscore/inc/cmsis_gcc.h ****   \details Assigns the given value to the Base Priority register.
 489:../cmsiscore/inc/cmsis_gcc.h ****   \param [in]    basePri  Base Priority value to set
 490:../cmsiscore/inc/cmsis_gcc.h ****  */
 491:../cmsiscore/inc/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_BASEPRI(uint32_t basePri)
 492:../cmsiscore/inc/cmsis_gcc.h **** {
 493:../cmsiscore/inc/cmsis_gcc.h ****   __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 494:../cmsiscore/inc/cmsis_gcc.h **** }
 495:../cmsiscore/inc/cmsis_gcc.h **** 
 496:../cmsiscore/inc/cmsis_gcc.h **** 
 497:../cmsiscore/inc/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 498:../cmsiscore/inc/cmsis_gcc.h **** /**
 499:../cmsiscore/inc/cmsis_gcc.h ****   \brief   Set Base Priority (non-secure)
 500:../cmsiscore/inc/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Base Priority register when in secure state.
 501:../cmsiscore/inc/cmsis_gcc.h ****   \param [in]    basePri  Base Priority value to set
 502:../cmsiscore/inc/cmsis_gcc.h ****  */
 503:../cmsiscore/inc/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_BASEPRI_NS(uint32_t basePri)
 504:../cmsiscore/inc/cmsis_gcc.h **** {
 505:../cmsiscore/inc/cmsis_gcc.h ****   __ASM volatile ("MSR basepri_ns, %0" : : "r" (basePri) : "memory");
 506:../cmsiscore/inc/cmsis_gcc.h **** }
 507:../cmsiscore/inc/cmsis_gcc.h **** #endif
 508:../cmsiscore/inc/cmsis_gcc.h **** 
 509:../cmsiscore/inc/cmsis_gcc.h **** 
 510:../cmsiscore/inc/cmsis_gcc.h **** /**
 511:../cmsiscore/inc/cmsis_gcc.h ****   \brief   Set Base Priority with condition
 512:../cmsiscore/inc/cmsis_gcc.h ****   \details Assigns the given value to the Base Priority register only if BASEPRI masking is disable
 513:../cmsiscore/inc/cmsis_gcc.h ****            or the new value increases the BASEPRI priority level.
 514:../cmsiscore/inc/cmsis_gcc.h ****   \param [in]    basePri  Base Priority value to set
 515:../cmsiscore/inc/cmsis_gcc.h ****  */
 516:../cmsiscore/inc/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_BASEPRI_MAX(uint32_t basePri)
 517:../cmsiscore/inc/cmsis_gcc.h **** {
 518:../cmsiscore/inc/cmsis_gcc.h ****   __ASM volatile ("MSR basepri_max, %0" : : "r" (basePri) : "memory");
 519:../cmsiscore/inc/cmsis_gcc.h **** }
 520:../cmsiscore/inc/cmsis_gcc.h **** 
 521:../cmsiscore/inc/cmsis_gcc.h **** 
 522:../cmsiscore/inc/cmsis_gcc.h **** /**
 523:../cmsiscore/inc/cmsis_gcc.h ****   \brief   Get Fault Mask
 524:../cmsiscore/inc/cmsis_gcc.h ****   \details Returns the current value of the Fault Mask register.
 525:../cmsiscore/inc/cmsis_gcc.h ****   \return               Fault Mask register value
 526:../cmsiscore/inc/cmsis_gcc.h ****  */
 527:../cmsiscore/inc/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_FAULTMASK(void)
 528:../cmsiscore/inc/cmsis_gcc.h **** {
 529:../cmsiscore/inc/cmsis_gcc.h ****   uint32_t result;
 530:../cmsiscore/inc/cmsis_gcc.h **** 
 531:../cmsiscore/inc/cmsis_gcc.h ****   __ASM volatile ("MRS %0, faultmask" : "=r" (result) );
 532:../cmsiscore/inc/cmsis_gcc.h ****   return(result);
 533:../cmsiscore/inc/cmsis_gcc.h **** }
 534:../cmsiscore/inc/cmsis_gcc.h **** 
 535:../cmsiscore/inc/cmsis_gcc.h **** 
 536:../cmsiscore/inc/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 537:../cmsiscore/inc/cmsis_gcc.h **** /**
 538:../cmsiscore/inc/cmsis_gcc.h ****   \brief   Get Fault Mask (non-secure)
 539:../cmsiscore/inc/cmsis_gcc.h ****   \details Returns the current value of the non-secure Fault Mask register when in secure state.
 540:../cmsiscore/inc/cmsis_gcc.h ****   \return               Fault Mask register value
 541:../cmsiscore/inc/cmsis_gcc.h ****  */
 542:../cmsiscore/inc/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_FAULTMASK_NS(void)
 543:../cmsiscore/inc/cmsis_gcc.h **** {
ARM GAS  /tmp/cciAnlD7.s 			page 23


 544:../cmsiscore/inc/cmsis_gcc.h ****   uint32_t result;
 545:../cmsiscore/inc/cmsis_gcc.h **** 
 546:../cmsiscore/inc/cmsis_gcc.h ****   __ASM volatile ("MRS %0, faultmask_ns" : "=r" (result) );
 547:../cmsiscore/inc/cmsis_gcc.h ****   return(result);
 548:../cmsiscore/inc/cmsis_gcc.h **** }
 549:../cmsiscore/inc/cmsis_gcc.h **** #endif
 550:../cmsiscore/inc/cmsis_gcc.h **** 
 551:../cmsiscore/inc/cmsis_gcc.h **** 
 552:../cmsiscore/inc/cmsis_gcc.h **** /**
 553:../cmsiscore/inc/cmsis_gcc.h ****   \brief   Set Fault Mask
 554:../cmsiscore/inc/cmsis_gcc.h ****   \details Assigns the given value to the Fault Mask register.
 555:../cmsiscore/inc/cmsis_gcc.h ****   \param [in]    faultMask  Fault Mask value to set
 556:../cmsiscore/inc/cmsis_gcc.h ****  */
 557:../cmsiscore/inc/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_FAULTMASK(uint32_t faultMask)
 558:../cmsiscore/inc/cmsis_gcc.h **** {
 559:../cmsiscore/inc/cmsis_gcc.h ****   __ASM volatile ("MSR faultmask, %0" : : "r" (faultMask) : "memory");
 560:../cmsiscore/inc/cmsis_gcc.h **** }
 561:../cmsiscore/inc/cmsis_gcc.h **** 
 562:../cmsiscore/inc/cmsis_gcc.h **** 
 563:../cmsiscore/inc/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE ) && (__ARM_FEATURE_CMSE == 3))
 564:../cmsiscore/inc/cmsis_gcc.h **** /**
 565:../cmsiscore/inc/cmsis_gcc.h ****   \brief   Set Fault Mask (non-secure)
 566:../cmsiscore/inc/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Fault Mask register when in secure state.
 567:../cmsiscore/inc/cmsis_gcc.h ****   \param [in]    faultMask  Fault Mask value to set
 568:../cmsiscore/inc/cmsis_gcc.h ****  */
 569:../cmsiscore/inc/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_FAULTMASK_NS(uint32_t faultMask)
 570:../cmsiscore/inc/cmsis_gcc.h **** {
 571:../cmsiscore/inc/cmsis_gcc.h ****   __ASM volatile ("MSR faultmask_ns, %0" : : "r" (faultMask) : "memory");
 572:../cmsiscore/inc/cmsis_gcc.h **** }
 573:../cmsiscore/inc/cmsis_gcc.h **** #endif
 574:../cmsiscore/inc/cmsis_gcc.h **** 
 575:../cmsiscore/inc/cmsis_gcc.h **** #endif /* ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
 576:../cmsiscore/inc/cmsis_gcc.h ****            (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
 577:../cmsiscore/inc/cmsis_gcc.h ****            (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    ) */
 578:../cmsiscore/inc/cmsis_gcc.h **** 
 579:../cmsiscore/inc/cmsis_gcc.h **** 
 580:../cmsiscore/inc/cmsis_gcc.h **** #if ((defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) || \
 581:../cmsiscore/inc/cmsis_gcc.h ****      (defined (__ARM_ARCH_8M_BASE__ ) && (__ARM_ARCH_8M_BASE__ == 1))    )
 582:../cmsiscore/inc/cmsis_gcc.h **** 
 583:../cmsiscore/inc/cmsis_gcc.h **** /**
 584:../cmsiscore/inc/cmsis_gcc.h ****   \brief   Get Process Stack Pointer Limit
 585:../cmsiscore/inc/cmsis_gcc.h ****   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
 586:../cmsiscore/inc/cmsis_gcc.h ****   Stack Pointer Limit register hence zero is returned always in non-secure
 587:../cmsiscore/inc/cmsis_gcc.h ****   mode.
 588:../cmsiscore/inc/cmsis_gcc.h ****   
 589:../cmsiscore/inc/cmsis_gcc.h ****   \details Returns the current value of the Process Stack Pointer Limit (PSPLIM).
 590:../cmsiscore/inc/cmsis_gcc.h ****   \return               PSPLIM Register value
 591:../cmsiscore/inc/cmsis_gcc.h ****  */
 592:../cmsiscore/inc/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_PSPLIM(void)
 593:../cmsiscore/inc/cmsis_gcc.h **** {
 594:../cmsiscore/inc/cmsis_gcc.h **** #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \
 595:../cmsiscore/inc/cmsis_gcc.h ****     (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))
 596:../cmsiscore/inc/cmsis_gcc.h ****     // without main extensions, the non-secure PSPLIM is RAZ/WI
 597:../cmsiscore/inc/cmsis_gcc.h ****   return 0U;
 598:../cmsiscore/inc/cmsis_gcc.h **** #else
 599:../cmsiscore/inc/cmsis_gcc.h ****   uint32_t result;
 600:../cmsiscore/inc/cmsis_gcc.h ****   __ASM volatile ("MRS %0, psplim"  : "=r" (result) );
ARM GAS  /tmp/cciAnlD7.s 			page 24


 601:../cmsiscore/inc/cmsis_gcc.h ****   return result;
 602:../cmsiscore/inc/cmsis_gcc.h **** #endif
 603:../cmsiscore/inc/cmsis_gcc.h **** }
 604:../cmsiscore/inc/cmsis_gcc.h **** 
 605:../cmsiscore/inc/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3))
 606:../cmsiscore/inc/cmsis_gcc.h **** /**
 607:../cmsiscore/inc/cmsis_gcc.h ****   \brief   Get Process Stack Pointer Limit (non-secure)
 608:../cmsiscore/inc/cmsis_gcc.h ****   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
 609:../cmsiscore/inc/cmsis_gcc.h ****   Stack Pointer Limit register hence zero is returned always.
 610:../cmsiscore/inc/cmsis_gcc.h **** 
 611:../cmsiscore/inc/cmsis_gcc.h ****   \details Returns the current value of the non-secure Process Stack Pointer Limit (PSPLIM) when in
 612:../cmsiscore/inc/cmsis_gcc.h ****   \return               PSPLIM Register value
 613:../cmsiscore/inc/cmsis_gcc.h ****  */
 614:../cmsiscore/inc/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_PSPLIM_NS(void)
 615:../cmsiscore/inc/cmsis_gcc.h **** {
 616:../cmsiscore/inc/cmsis_gcc.h **** #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)))
 617:../cmsiscore/inc/cmsis_gcc.h ****   // without main extensions, the non-secure PSPLIM is RAZ/WI
 618:../cmsiscore/inc/cmsis_gcc.h ****   return 0U;
 619:../cmsiscore/inc/cmsis_gcc.h **** #else
 620:../cmsiscore/inc/cmsis_gcc.h ****   uint32_t result;
 621:../cmsiscore/inc/cmsis_gcc.h ****   __ASM volatile ("MRS %0, psplim_ns"  : "=r" (result) );
 622:../cmsiscore/inc/cmsis_gcc.h ****   return result;
 623:../cmsiscore/inc/cmsis_gcc.h **** #endif
 624:../cmsiscore/inc/cmsis_gcc.h **** }
 625:../cmsiscore/inc/cmsis_gcc.h **** #endif
 626:../cmsiscore/inc/cmsis_gcc.h **** 
 627:../cmsiscore/inc/cmsis_gcc.h **** 
 628:../cmsiscore/inc/cmsis_gcc.h **** /**
 629:../cmsiscore/inc/cmsis_gcc.h ****   \brief   Set Process Stack Pointer Limit
 630:../cmsiscore/inc/cmsis_gcc.h ****   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
 631:../cmsiscore/inc/cmsis_gcc.h ****   Stack Pointer Limit register hence the write is silently ignored in non-secure
 632:../cmsiscore/inc/cmsis_gcc.h ****   mode.
 633:../cmsiscore/inc/cmsis_gcc.h ****   
 634:../cmsiscore/inc/cmsis_gcc.h ****   \details Assigns the given value to the Process Stack Pointer Limit (PSPLIM).
 635:../cmsiscore/inc/cmsis_gcc.h ****   \param [in]    ProcStackPtrLimit  Process Stack Pointer Limit value to set
 636:../cmsiscore/inc/cmsis_gcc.h ****  */
 637:../cmsiscore/inc/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_PSPLIM(uint32_t ProcStackPtrLimit)
 638:../cmsiscore/inc/cmsis_gcc.h **** {
 639:../cmsiscore/inc/cmsis_gcc.h **** #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \
 640:../cmsiscore/inc/cmsis_gcc.h ****     (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))
 641:../cmsiscore/inc/cmsis_gcc.h ****   // without main extensions, the non-secure PSPLIM is RAZ/WI
 642:../cmsiscore/inc/cmsis_gcc.h ****   (void)ProcStackPtrLimit;
 643:../cmsiscore/inc/cmsis_gcc.h **** #else
 644:../cmsiscore/inc/cmsis_gcc.h ****   __ASM volatile ("MSR psplim, %0" : : "r" (ProcStackPtrLimit));
 645:../cmsiscore/inc/cmsis_gcc.h **** #endif
 646:../cmsiscore/inc/cmsis_gcc.h **** }
 647:../cmsiscore/inc/cmsis_gcc.h **** 
 648:../cmsiscore/inc/cmsis_gcc.h **** 
 649:../cmsiscore/inc/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE  ) && (__ARM_FEATURE_CMSE   == 3))
 650:../cmsiscore/inc/cmsis_gcc.h **** /**
 651:../cmsiscore/inc/cmsis_gcc.h ****   \brief   Set Process Stack Pointer (non-secure)
 652:../cmsiscore/inc/cmsis_gcc.h ****   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
 653:../cmsiscore/inc/cmsis_gcc.h ****   Stack Pointer Limit register hence the write is silently ignored.
 654:../cmsiscore/inc/cmsis_gcc.h **** 
 655:../cmsiscore/inc/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Process Stack Pointer Limit (PSPLIM) when in s
 656:../cmsiscore/inc/cmsis_gcc.h ****   \param [in]    ProcStackPtrLimit  Process Stack Pointer Limit value to set
 657:../cmsiscore/inc/cmsis_gcc.h ****  */
ARM GAS  /tmp/cciAnlD7.s 			page 25


 658:../cmsiscore/inc/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_PSPLIM_NS(uint32_t ProcStackPtrLimit)
 659:../cmsiscore/inc/cmsis_gcc.h **** {
 660:../cmsiscore/inc/cmsis_gcc.h **** #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)))
 661:../cmsiscore/inc/cmsis_gcc.h ****   // without main extensions, the non-secure PSPLIM is RAZ/WI
 662:../cmsiscore/inc/cmsis_gcc.h ****   (void)ProcStackPtrLimit;
 663:../cmsiscore/inc/cmsis_gcc.h **** #else
 664:../cmsiscore/inc/cmsis_gcc.h ****   __ASM volatile ("MSR psplim_ns, %0\n" : : "r" (ProcStackPtrLimit));
 665:../cmsiscore/inc/cmsis_gcc.h **** #endif
 666:../cmsiscore/inc/cmsis_gcc.h **** }
 667:../cmsiscore/inc/cmsis_gcc.h **** #endif
 668:../cmsiscore/inc/cmsis_gcc.h **** 
 669:../cmsiscore/inc/cmsis_gcc.h **** 
 670:../cmsiscore/inc/cmsis_gcc.h **** /**
 671:../cmsiscore/inc/cmsis_gcc.h ****   \brief   Get Main Stack Pointer Limit
 672:../cmsiscore/inc/cmsis_gcc.h ****   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
 673:../cmsiscore/inc/cmsis_gcc.h ****   Stack Pointer Limit register hence zero is returned always in non-secure
 674:../cmsiscore/inc/cmsis_gcc.h ****   mode.
 675:../cmsiscore/inc/cmsis_gcc.h **** 
 676:../cmsiscore/inc/cmsis_gcc.h ****   \details Returns the current value of the Main Stack Pointer Limit (MSPLIM).
 677:../cmsiscore/inc/cmsis_gcc.h ****   \return               MSPLIM Register value
 678:../cmsiscore/inc/cmsis_gcc.h ****  */
 679:../cmsiscore/inc/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_MSPLIM(void)
 680:../cmsiscore/inc/cmsis_gcc.h **** {
 681:../cmsiscore/inc/cmsis_gcc.h **** #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \
 682:../cmsiscore/inc/cmsis_gcc.h ****     (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))
 683:../cmsiscore/inc/cmsis_gcc.h ****   // without main extensions, the non-secure MSPLIM is RAZ/WI
 684:../cmsiscore/inc/cmsis_gcc.h ****   return 0U;
 685:../cmsiscore/inc/cmsis_gcc.h **** #else
 686:../cmsiscore/inc/cmsis_gcc.h ****   uint32_t result;
 687:../cmsiscore/inc/cmsis_gcc.h ****   __ASM volatile ("MRS %0, msplim" : "=r" (result) );
 688:../cmsiscore/inc/cmsis_gcc.h ****   return result;
 689:../cmsiscore/inc/cmsis_gcc.h **** #endif
 690:../cmsiscore/inc/cmsis_gcc.h **** }
 691:../cmsiscore/inc/cmsis_gcc.h **** 
 692:../cmsiscore/inc/cmsis_gcc.h **** 
 693:../cmsiscore/inc/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE  ) && (__ARM_FEATURE_CMSE   == 3))
 694:../cmsiscore/inc/cmsis_gcc.h **** /**
 695:../cmsiscore/inc/cmsis_gcc.h ****   \brief   Get Main Stack Pointer Limit (non-secure)
 696:../cmsiscore/inc/cmsis_gcc.h ****   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
 697:../cmsiscore/inc/cmsis_gcc.h ****   Stack Pointer Limit register hence zero is returned always.
 698:../cmsiscore/inc/cmsis_gcc.h **** 
 699:../cmsiscore/inc/cmsis_gcc.h ****   \details Returns the current value of the non-secure Main Stack Pointer Limit(MSPLIM) when in sec
 700:../cmsiscore/inc/cmsis_gcc.h ****   \return               MSPLIM Register value
 701:../cmsiscore/inc/cmsis_gcc.h ****  */
 702:../cmsiscore/inc/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __TZ_get_MSPLIM_NS(void)
 703:../cmsiscore/inc/cmsis_gcc.h **** {
 704:../cmsiscore/inc/cmsis_gcc.h **** #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)))
 705:../cmsiscore/inc/cmsis_gcc.h ****   // without main extensions, the non-secure MSPLIM is RAZ/WI
 706:../cmsiscore/inc/cmsis_gcc.h ****   return 0U;
 707:../cmsiscore/inc/cmsis_gcc.h **** #else
 708:../cmsiscore/inc/cmsis_gcc.h ****   uint32_t result;
 709:../cmsiscore/inc/cmsis_gcc.h ****   __ASM volatile ("MRS %0, msplim_ns" : "=r" (result) );
 710:../cmsiscore/inc/cmsis_gcc.h ****   return result;
 711:../cmsiscore/inc/cmsis_gcc.h **** #endif
 712:../cmsiscore/inc/cmsis_gcc.h **** }
 713:../cmsiscore/inc/cmsis_gcc.h **** #endif
 714:../cmsiscore/inc/cmsis_gcc.h **** 
ARM GAS  /tmp/cciAnlD7.s 			page 26


 715:../cmsiscore/inc/cmsis_gcc.h **** 
 716:../cmsiscore/inc/cmsis_gcc.h **** /**
 717:../cmsiscore/inc/cmsis_gcc.h ****   \brief   Set Main Stack Pointer Limit
 718:../cmsiscore/inc/cmsis_gcc.h ****   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
 719:../cmsiscore/inc/cmsis_gcc.h ****   Stack Pointer Limit register hence the write is silently ignored in non-secure
 720:../cmsiscore/inc/cmsis_gcc.h ****   mode.
 721:../cmsiscore/inc/cmsis_gcc.h **** 
 722:../cmsiscore/inc/cmsis_gcc.h ****   \details Assigns the given value to the Main Stack Pointer Limit (MSPLIM).
 723:../cmsiscore/inc/cmsis_gcc.h ****   \param [in]    MainStackPtrLimit  Main Stack Pointer Limit value to set
 724:../cmsiscore/inc/cmsis_gcc.h ****  */
 725:../cmsiscore/inc/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_MSPLIM(uint32_t MainStackPtrLimit)
 726:../cmsiscore/inc/cmsis_gcc.h **** {
 727:../cmsiscore/inc/cmsis_gcc.h **** #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) && \
 728:../cmsiscore/inc/cmsis_gcc.h ****     (!defined (__ARM_FEATURE_CMSE) || (__ARM_FEATURE_CMSE < 3)))
 729:../cmsiscore/inc/cmsis_gcc.h ****   // without main extensions, the non-secure MSPLIM is RAZ/WI
 730:../cmsiscore/inc/cmsis_gcc.h ****   (void)MainStackPtrLimit;
 731:../cmsiscore/inc/cmsis_gcc.h **** #else
 732:../cmsiscore/inc/cmsis_gcc.h ****   __ASM volatile ("MSR msplim, %0" : : "r" (MainStackPtrLimit));
 733:../cmsiscore/inc/cmsis_gcc.h **** #endif
 734:../cmsiscore/inc/cmsis_gcc.h **** }
 735:../cmsiscore/inc/cmsis_gcc.h **** 
 736:../cmsiscore/inc/cmsis_gcc.h **** 
 737:../cmsiscore/inc/cmsis_gcc.h **** #if (defined (__ARM_FEATURE_CMSE  ) && (__ARM_FEATURE_CMSE   == 3))
 738:../cmsiscore/inc/cmsis_gcc.h **** /**
 739:../cmsiscore/inc/cmsis_gcc.h ****   \brief   Set Main Stack Pointer Limit (non-secure)
 740:../cmsiscore/inc/cmsis_gcc.h ****   Devices without ARMv8-M Main Extensions (i.e. Cortex-M23) lack the non-secure
 741:../cmsiscore/inc/cmsis_gcc.h ****   Stack Pointer Limit register hence the write is silently ignored.
 742:../cmsiscore/inc/cmsis_gcc.h **** 
 743:../cmsiscore/inc/cmsis_gcc.h ****   \details Assigns the given value to the non-secure Main Stack Pointer Limit (MSPLIM) when in secu
 744:../cmsiscore/inc/cmsis_gcc.h ****   \param [in]    MainStackPtrLimit  Main Stack Pointer value to set
 745:../cmsiscore/inc/cmsis_gcc.h ****  */
 746:../cmsiscore/inc/cmsis_gcc.h **** __STATIC_FORCEINLINE void __TZ_set_MSPLIM_NS(uint32_t MainStackPtrLimit)
 747:../cmsiscore/inc/cmsis_gcc.h **** {
 748:../cmsiscore/inc/cmsis_gcc.h **** #if (!(defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)))
 749:../cmsiscore/inc/cmsis_gcc.h ****   // without main extensions, the non-secure MSPLIM is RAZ/WI
 750:../cmsiscore/inc/cmsis_gcc.h ****   (void)MainStackPtrLimit;
 751:../cmsiscore/inc/cmsis_gcc.h **** #else
 752:../cmsiscore/inc/cmsis_gcc.h ****   __ASM volatile ("MSR msplim_ns, %0" : : "r" (MainStackPtrLimit));
 753:../cmsiscore/inc/cmsis_gcc.h **** #endif
 754:../cmsiscore/inc/cmsis_gcc.h **** }
 755:../cmsiscore/inc/cmsis_gcc.h **** #endif
 756:../cmsiscore/inc/cmsis_gcc.h **** 
 757:../cmsiscore/inc/cmsis_gcc.h **** #endif /* ((defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1)) || \
 758:../cmsiscore/inc/cmsis_gcc.h ****            (defined (__ARM_ARCH_8M_BASE__ ) && (__ARM_ARCH_8M_BASE__ == 1))    ) */
 759:../cmsiscore/inc/cmsis_gcc.h **** 
 760:../cmsiscore/inc/cmsis_gcc.h **** 
 761:../cmsiscore/inc/cmsis_gcc.h **** /**
 762:../cmsiscore/inc/cmsis_gcc.h ****   \brief   Get FPSCR
 763:../cmsiscore/inc/cmsis_gcc.h ****   \details Returns the current value of the Floating Point Status/Control register.
 764:../cmsiscore/inc/cmsis_gcc.h ****   \return               Floating Point Status/Control register value
 765:../cmsiscore/inc/cmsis_gcc.h ****  */
 766:../cmsiscore/inc/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __get_FPSCR(void)
 767:../cmsiscore/inc/cmsis_gcc.h **** {
 768:../cmsiscore/inc/cmsis_gcc.h **** #if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) && \
 769:../cmsiscore/inc/cmsis_gcc.h ****      (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )
 770:../cmsiscore/inc/cmsis_gcc.h **** #if __has_builtin(__builtin_arm_get_fpscr) 
 771:../cmsiscore/inc/cmsis_gcc.h **** // Re-enable using built-in when GCC has been fixed
ARM GAS  /tmp/cciAnlD7.s 			page 27


 772:../cmsiscore/inc/cmsis_gcc.h **** // || (__GNUC__ > 7) || (__GNUC__ == 7 && __GNUC_MINOR__ >= 2)
 773:../cmsiscore/inc/cmsis_gcc.h ****   /* see https://gcc.gnu.org/ml/gcc-patches/2017-04/msg00443.html */
 774:../cmsiscore/inc/cmsis_gcc.h ****   return __builtin_arm_get_fpscr();
 775:../cmsiscore/inc/cmsis_gcc.h **** #else
 776:../cmsiscore/inc/cmsis_gcc.h ****   uint32_t result;
 777:../cmsiscore/inc/cmsis_gcc.h **** 
 778:../cmsiscore/inc/cmsis_gcc.h ****   __ASM volatile ("VMRS %0, fpscr" : "=r" (result) );
 779:../cmsiscore/inc/cmsis_gcc.h ****   return(result);
 780:../cmsiscore/inc/cmsis_gcc.h **** #endif
 781:../cmsiscore/inc/cmsis_gcc.h **** #else
 782:../cmsiscore/inc/cmsis_gcc.h ****   return(0U);
 783:../cmsiscore/inc/cmsis_gcc.h **** #endif
 784:../cmsiscore/inc/cmsis_gcc.h **** }
 785:../cmsiscore/inc/cmsis_gcc.h **** 
 786:../cmsiscore/inc/cmsis_gcc.h **** 
 787:../cmsiscore/inc/cmsis_gcc.h **** /**
 788:../cmsiscore/inc/cmsis_gcc.h ****   \brief   Set FPSCR
 789:../cmsiscore/inc/cmsis_gcc.h ****   \details Assigns the given value to the Floating Point Status/Control register.
 790:../cmsiscore/inc/cmsis_gcc.h ****   \param [in]    fpscr  Floating Point Status/Control value to set
 791:../cmsiscore/inc/cmsis_gcc.h ****  */
 792:../cmsiscore/inc/cmsis_gcc.h **** __STATIC_FORCEINLINE void __set_FPSCR(uint32_t fpscr)
 793:../cmsiscore/inc/cmsis_gcc.h **** {
 794:../cmsiscore/inc/cmsis_gcc.h **** #if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) && \
 795:../cmsiscore/inc/cmsis_gcc.h ****      (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )
 796:../cmsiscore/inc/cmsis_gcc.h **** #if __has_builtin(__builtin_arm_set_fpscr)
 797:../cmsiscore/inc/cmsis_gcc.h **** // Re-enable using built-in when GCC has been fixed
 798:../cmsiscore/inc/cmsis_gcc.h **** // || (__GNUC__ > 7) || (__GNUC__ == 7 && __GNUC_MINOR__ >= 2)
 799:../cmsiscore/inc/cmsis_gcc.h ****   /* see https://gcc.gnu.org/ml/gcc-patches/2017-04/msg00443.html */
 800:../cmsiscore/inc/cmsis_gcc.h ****   __builtin_arm_set_fpscr(fpscr);
 801:../cmsiscore/inc/cmsis_gcc.h **** #else
 802:../cmsiscore/inc/cmsis_gcc.h ****   __ASM volatile ("VMSR fpscr, %0" : : "r" (fpscr) : "vfpcc", "memory");
 803:../cmsiscore/inc/cmsis_gcc.h **** #endif
 804:../cmsiscore/inc/cmsis_gcc.h **** #else
 805:../cmsiscore/inc/cmsis_gcc.h ****   (void)fpscr;
 806:../cmsiscore/inc/cmsis_gcc.h **** #endif
 807:../cmsiscore/inc/cmsis_gcc.h **** }
 808:../cmsiscore/inc/cmsis_gcc.h **** 
 809:../cmsiscore/inc/cmsis_gcc.h **** 
 810:../cmsiscore/inc/cmsis_gcc.h **** /*@} end of CMSIS_Core_RegAccFunctions */
 811:../cmsiscore/inc/cmsis_gcc.h **** 
 812:../cmsiscore/inc/cmsis_gcc.h **** 
 813:../cmsiscore/inc/cmsis_gcc.h **** /* ##########################  Core Instruction Access  ######################### */
 814:../cmsiscore/inc/cmsis_gcc.h **** /** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
 815:../cmsiscore/inc/cmsis_gcc.h ****   Access to dedicated instructions
 816:../cmsiscore/inc/cmsis_gcc.h ****   @{
 817:../cmsiscore/inc/cmsis_gcc.h **** */
 818:../cmsiscore/inc/cmsis_gcc.h **** 
 819:../cmsiscore/inc/cmsis_gcc.h **** /* Define macros for porting to both thumb1 and thumb2.
 820:../cmsiscore/inc/cmsis_gcc.h ****  * For thumb1, use low register (r0-r7), specified by constraint "l"
 821:../cmsiscore/inc/cmsis_gcc.h ****  * Otherwise, use general registers, specified by constraint "r" */
 822:../cmsiscore/inc/cmsis_gcc.h **** #if defined (__thumb__) && !defined (__thumb2__)
 823:../cmsiscore/inc/cmsis_gcc.h **** #define __CMSIS_GCC_OUT_REG(r) "=l" (r)
 824:../cmsiscore/inc/cmsis_gcc.h **** #define __CMSIS_GCC_RW_REG(r) "+l" (r)
 825:../cmsiscore/inc/cmsis_gcc.h **** #define __CMSIS_GCC_USE_REG(r) "l" (r)
 826:../cmsiscore/inc/cmsis_gcc.h **** #else
 827:../cmsiscore/inc/cmsis_gcc.h **** #define __CMSIS_GCC_OUT_REG(r) "=r" (r)
 828:../cmsiscore/inc/cmsis_gcc.h **** #define __CMSIS_GCC_RW_REG(r) "+r" (r)
ARM GAS  /tmp/cciAnlD7.s 			page 28


 829:../cmsiscore/inc/cmsis_gcc.h **** #define __CMSIS_GCC_USE_REG(r) "r" (r)
 830:../cmsiscore/inc/cmsis_gcc.h **** #endif
 831:../cmsiscore/inc/cmsis_gcc.h **** 
 832:../cmsiscore/inc/cmsis_gcc.h **** /**
 833:../cmsiscore/inc/cmsis_gcc.h ****   \brief   No Operation
 834:../cmsiscore/inc/cmsis_gcc.h ****   \details No Operation does nothing. This instruction can be used for code alignment purposes.
 835:../cmsiscore/inc/cmsis_gcc.h ****  */
 836:../cmsiscore/inc/cmsis_gcc.h **** #define __NOP()                             __ASM volatile ("nop")
 837:../cmsiscore/inc/cmsis_gcc.h **** 
 838:../cmsiscore/inc/cmsis_gcc.h **** /**
 839:../cmsiscore/inc/cmsis_gcc.h ****   \brief   Wait For Interrupt
 840:../cmsiscore/inc/cmsis_gcc.h ****   \details Wait For Interrupt is a hint instruction that suspends execution until one of a number o
 841:../cmsiscore/inc/cmsis_gcc.h ****  */
 842:../cmsiscore/inc/cmsis_gcc.h **** #define __WFI()                             __ASM volatile ("wfi")
 843:../cmsiscore/inc/cmsis_gcc.h **** 
 844:../cmsiscore/inc/cmsis_gcc.h **** 
 845:../cmsiscore/inc/cmsis_gcc.h **** /**
 846:../cmsiscore/inc/cmsis_gcc.h ****   \brief   Wait For Event
 847:../cmsiscore/inc/cmsis_gcc.h ****   \details Wait For Event is a hint instruction that permits the processor to enter
 848:../cmsiscore/inc/cmsis_gcc.h ****            a low-power state until one of a number of events occurs.
 849:../cmsiscore/inc/cmsis_gcc.h ****  */
 850:../cmsiscore/inc/cmsis_gcc.h **** #define __WFE()                             __ASM volatile ("wfe")
 851:../cmsiscore/inc/cmsis_gcc.h **** 
 852:../cmsiscore/inc/cmsis_gcc.h **** 
 853:../cmsiscore/inc/cmsis_gcc.h **** /**
 854:../cmsiscore/inc/cmsis_gcc.h ****   \brief   Send Event
 855:../cmsiscore/inc/cmsis_gcc.h ****   \details Send Event is a hint instruction. It causes an event to be signaled to the CPU.
 856:../cmsiscore/inc/cmsis_gcc.h ****  */
 857:../cmsiscore/inc/cmsis_gcc.h **** #define __SEV()                             __ASM volatile ("sev")
 858:../cmsiscore/inc/cmsis_gcc.h **** 
 859:../cmsiscore/inc/cmsis_gcc.h **** 
 860:../cmsiscore/inc/cmsis_gcc.h **** /**
 861:../cmsiscore/inc/cmsis_gcc.h ****   \brief   Instruction Synchronization Barrier
 862:../cmsiscore/inc/cmsis_gcc.h ****   \details Instruction Synchronization Barrier flushes the pipeline in the processor,
 863:../cmsiscore/inc/cmsis_gcc.h ****            so that all instructions following the ISB are fetched from cache or memory,
 864:../cmsiscore/inc/cmsis_gcc.h ****            after the instruction has been completed.
 865:../cmsiscore/inc/cmsis_gcc.h ****  */
 866:../cmsiscore/inc/cmsis_gcc.h **** __STATIC_FORCEINLINE void __ISB(void)
 867:../cmsiscore/inc/cmsis_gcc.h **** {
 868:../cmsiscore/inc/cmsis_gcc.h ****   __ASM volatile ("isb 0xF":::"memory");
 869:../cmsiscore/inc/cmsis_gcc.h **** }
 870:../cmsiscore/inc/cmsis_gcc.h **** 
 871:../cmsiscore/inc/cmsis_gcc.h **** 
 872:../cmsiscore/inc/cmsis_gcc.h **** /**
 873:../cmsiscore/inc/cmsis_gcc.h ****   \brief   Data Synchronization Barrier
 874:../cmsiscore/inc/cmsis_gcc.h ****   \details Acts as a special kind of Data Memory Barrier.
 875:../cmsiscore/inc/cmsis_gcc.h ****            It completes when all explicit memory accesses before this instruction complete.
 876:../cmsiscore/inc/cmsis_gcc.h ****  */
 877:../cmsiscore/inc/cmsis_gcc.h **** __STATIC_FORCEINLINE void __DSB(void)
 878:../cmsiscore/inc/cmsis_gcc.h **** {
 879:../cmsiscore/inc/cmsis_gcc.h ****   __ASM volatile ("dsb 0xF":::"memory");
 880:../cmsiscore/inc/cmsis_gcc.h **** }
 881:../cmsiscore/inc/cmsis_gcc.h **** 
 882:../cmsiscore/inc/cmsis_gcc.h **** 
 883:../cmsiscore/inc/cmsis_gcc.h **** /**
 884:../cmsiscore/inc/cmsis_gcc.h ****   \brief   Data Memory Barrier
 885:../cmsiscore/inc/cmsis_gcc.h ****   \details Ensures the apparent order of the explicit memory operations before
ARM GAS  /tmp/cciAnlD7.s 			page 29


 886:../cmsiscore/inc/cmsis_gcc.h ****            and after the instruction, without ensuring their completion.
 887:../cmsiscore/inc/cmsis_gcc.h ****  */
 888:../cmsiscore/inc/cmsis_gcc.h **** __STATIC_FORCEINLINE void __DMB(void)
 889:../cmsiscore/inc/cmsis_gcc.h **** {
 890:../cmsiscore/inc/cmsis_gcc.h ****   __ASM volatile ("dmb 0xF":::"memory");
 891:../cmsiscore/inc/cmsis_gcc.h **** }
 892:../cmsiscore/inc/cmsis_gcc.h **** 
 893:../cmsiscore/inc/cmsis_gcc.h **** 
 894:../cmsiscore/inc/cmsis_gcc.h **** /**
 895:../cmsiscore/inc/cmsis_gcc.h ****   \brief   Reverse byte order (32 bit)
 896:../cmsiscore/inc/cmsis_gcc.h ****   \details Reverses the byte order in unsigned integer value. For example, 0x12345678 becomes 0x785
 897:../cmsiscore/inc/cmsis_gcc.h ****   \param [in]    value  Value to reverse
 898:../cmsiscore/inc/cmsis_gcc.h ****   \return               Reversed value
 899:../cmsiscore/inc/cmsis_gcc.h ****  */
 900:../cmsiscore/inc/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __REV(uint32_t value)
 901:../cmsiscore/inc/cmsis_gcc.h **** {
 902:../cmsiscore/inc/cmsis_gcc.h **** #if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 5)
 903:../cmsiscore/inc/cmsis_gcc.h ****   return __builtin_bswap32(value);
 904:../cmsiscore/inc/cmsis_gcc.h **** #else
 905:../cmsiscore/inc/cmsis_gcc.h ****   uint32_t result;
 906:../cmsiscore/inc/cmsis_gcc.h **** 
 907:../cmsiscore/inc/cmsis_gcc.h ****   __ASM volatile ("rev %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
 908:../cmsiscore/inc/cmsis_gcc.h ****   return result;
 909:../cmsiscore/inc/cmsis_gcc.h **** #endif
 910:../cmsiscore/inc/cmsis_gcc.h **** }
 911:../cmsiscore/inc/cmsis_gcc.h **** 
 912:../cmsiscore/inc/cmsis_gcc.h **** 
 913:../cmsiscore/inc/cmsis_gcc.h **** /**
 914:../cmsiscore/inc/cmsis_gcc.h ****   \brief   Reverse byte order (16 bit)
 915:../cmsiscore/inc/cmsis_gcc.h ****   \details Reverses the byte order within each halfword of a word. For example, 0x12345678 becomes 
 916:../cmsiscore/inc/cmsis_gcc.h ****   \param [in]    value  Value to reverse
 917:../cmsiscore/inc/cmsis_gcc.h ****   \return               Reversed value
 918:../cmsiscore/inc/cmsis_gcc.h ****  */
 919:../cmsiscore/inc/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __REV16(uint32_t value)
 920:../cmsiscore/inc/cmsis_gcc.h **** {
 921:../cmsiscore/inc/cmsis_gcc.h ****   uint32_t result;
 922:../cmsiscore/inc/cmsis_gcc.h **** 
 923:../cmsiscore/inc/cmsis_gcc.h ****   __ASM volatile ("rev16 %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
 924:../cmsiscore/inc/cmsis_gcc.h ****   return result;
 925:../cmsiscore/inc/cmsis_gcc.h **** }
 926:../cmsiscore/inc/cmsis_gcc.h **** 
 927:../cmsiscore/inc/cmsis_gcc.h **** 
 928:../cmsiscore/inc/cmsis_gcc.h **** /**
 929:../cmsiscore/inc/cmsis_gcc.h ****   \brief   Reverse byte order (16 bit)
 930:../cmsiscore/inc/cmsis_gcc.h ****   \details Reverses the byte order in a 16-bit value and returns the signed 16-bit result. For exam
 931:../cmsiscore/inc/cmsis_gcc.h ****   \param [in]    value  Value to reverse
 932:../cmsiscore/inc/cmsis_gcc.h ****   \return               Reversed value
 933:../cmsiscore/inc/cmsis_gcc.h ****  */
 934:../cmsiscore/inc/cmsis_gcc.h **** __STATIC_FORCEINLINE int16_t __REVSH(int16_t value)
 935:../cmsiscore/inc/cmsis_gcc.h **** {
 936:../cmsiscore/inc/cmsis_gcc.h **** #if (__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)
 937:../cmsiscore/inc/cmsis_gcc.h ****   return (int16_t)__builtin_bswap16(value);
 938:../cmsiscore/inc/cmsis_gcc.h **** #else
 939:../cmsiscore/inc/cmsis_gcc.h ****   int16_t result;
 940:../cmsiscore/inc/cmsis_gcc.h **** 
 941:../cmsiscore/inc/cmsis_gcc.h ****   __ASM volatile ("revsh %0, %1" : __CMSIS_GCC_OUT_REG (result) : __CMSIS_GCC_USE_REG (value) );
 942:../cmsiscore/inc/cmsis_gcc.h ****   return result;
ARM GAS  /tmp/cciAnlD7.s 			page 30


 943:../cmsiscore/inc/cmsis_gcc.h **** #endif
 944:../cmsiscore/inc/cmsis_gcc.h **** }
 945:../cmsiscore/inc/cmsis_gcc.h **** 
 946:../cmsiscore/inc/cmsis_gcc.h **** 
 947:../cmsiscore/inc/cmsis_gcc.h **** /**
 948:../cmsiscore/inc/cmsis_gcc.h ****   \brief   Rotate Right in unsigned value (32 bit)
 949:../cmsiscore/inc/cmsis_gcc.h ****   \details Rotate Right (immediate) provides the value of the contents of a register rotated by a v
 950:../cmsiscore/inc/cmsis_gcc.h ****   \param [in]    op1  Value to rotate
 951:../cmsiscore/inc/cmsis_gcc.h ****   \param [in]    op2  Number of Bits to rotate
 952:../cmsiscore/inc/cmsis_gcc.h ****   \return               Rotated value
 953:../cmsiscore/inc/cmsis_gcc.h ****  */
 954:../cmsiscore/inc/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __ROR(uint32_t op1, uint32_t op2)
 955:../cmsiscore/inc/cmsis_gcc.h **** {
 956:../cmsiscore/inc/cmsis_gcc.h ****   op2 %= 32U;
 957:../cmsiscore/inc/cmsis_gcc.h ****   if (op2 == 0U)
 958:../cmsiscore/inc/cmsis_gcc.h ****   {
 959:../cmsiscore/inc/cmsis_gcc.h ****     return op1;
 960:../cmsiscore/inc/cmsis_gcc.h ****   }
 961:../cmsiscore/inc/cmsis_gcc.h ****   return (op1 >> op2) | (op1 << (32U - op2));
 962:../cmsiscore/inc/cmsis_gcc.h **** }
 963:../cmsiscore/inc/cmsis_gcc.h **** 
 964:../cmsiscore/inc/cmsis_gcc.h **** 
 965:../cmsiscore/inc/cmsis_gcc.h **** /**
 966:../cmsiscore/inc/cmsis_gcc.h ****   \brief   Breakpoint
 967:../cmsiscore/inc/cmsis_gcc.h ****   \details Causes the processor to enter Debug state.
 968:../cmsiscore/inc/cmsis_gcc.h ****            Debug tools can use this to investigate system state when the instruction at a particula
 969:../cmsiscore/inc/cmsis_gcc.h ****   \param [in]    value  is ignored by the processor.
 970:../cmsiscore/inc/cmsis_gcc.h ****                  If required, a debugger can use it to store additional information about the break
 971:../cmsiscore/inc/cmsis_gcc.h ****  */
 972:../cmsiscore/inc/cmsis_gcc.h **** #define __BKPT(value)                       __ASM volatile ("bkpt "#value)
 973:../cmsiscore/inc/cmsis_gcc.h **** 
 974:../cmsiscore/inc/cmsis_gcc.h **** 
 975:../cmsiscore/inc/cmsis_gcc.h **** /**
 976:../cmsiscore/inc/cmsis_gcc.h ****   \brief   Reverse bit order of value
 977:../cmsiscore/inc/cmsis_gcc.h ****   \details Reverses the bit order of the given value.
 978:../cmsiscore/inc/cmsis_gcc.h ****   \param [in]    value  Value to reverse
 979:../cmsiscore/inc/cmsis_gcc.h ****   \return               Reversed value
 980:../cmsiscore/inc/cmsis_gcc.h ****  */
 981:../cmsiscore/inc/cmsis_gcc.h **** __STATIC_FORCEINLINE uint32_t __RBIT(uint32_t value)
 982:../cmsiscore/inc/cmsis_gcc.h **** {
 983:../cmsiscore/inc/cmsis_gcc.h ****   uint32_t result;
 984:../cmsiscore/inc/cmsis_gcc.h **** 
 985:../cmsiscore/inc/cmsis_gcc.h **** #if ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
 986:../cmsiscore/inc/cmsis_gcc.h ****      (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
 987:../cmsiscore/inc/cmsis_gcc.h ****      (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    )
 988:../cmsiscore/inc/cmsis_gcc.h ****    __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 329              		.loc 2 988 0
 330              		.syntax unified
 331              	@ 988 "../cmsiscore/inc/cmsis_gcc.h" 1
 332 00bc 90FAA0F0 		rbit r0, r0	@ result, WakeUpPinx
 333              	@ 0 "" 2
 334              	.LVL3:
 335              		.thumb
 336              		.syntax unified
 337              	.LBE7:
 338              	.LBE6:
 384:src/stm32f1xx_hal_pwr.c ****   /* Check the parameter */
ARM GAS  /tmp/cciAnlD7.s 			page 31


 385:src/stm32f1xx_hal_pwr.c ****   assert_param(IS_PWR_WAKEUP_PIN(WakeUpPinx));
 386:src/stm32f1xx_hal_pwr.c ****   /* Enable the EWUPx pin */
 387:src/stm32f1xx_hal_pwr.c ****   *(__IO uint32_t *) CSR_EWUP_BB(WakeUpPinx) = (uint32_t)ENABLE;
 339              		.loc 1 387 0
 340 00c0 B0FA80F0 		clz	r0, r0	@ _3, result
 341 00c4 0122     		movs	r2, #1	@ tmp120,
 342 00c6 024B     		ldr	r3, .L37	@ tmp118,
 343 00c8 0344     		add	r3, r3, r0	@ tmp118, _3
 344 00ca 9B00     		lsls	r3, r3, #2	@ _7, tmp118,
 345 00cc 1A60     		str	r2, [r3]	@ tmp120, *_7
 346 00ce 7047     		bx	lr	@
 347              	.L38:
 348              		.align	2
 349              	.L37:
 350 00d0 20808310 		.word	277053472
 351              		.cfi_endproc
 352              	.LFE72:
 353              		.size	HAL_PWR_EnableWakeUpPin, .-HAL_PWR_EnableWakeUpPin
 354              		.align	1
 355              		.global	HAL_PWR_DisableWakeUpPin
 356              		.syntax unified
 357              		.thumb
 358              		.thumb_func
 359              		.fpu softvfp
 360              		.type	HAL_PWR_DisableWakeUpPin, %function
 361              	HAL_PWR_DisableWakeUpPin:
 362              	.LFB73:
 388:src/stm32f1xx_hal_pwr.c **** }
 389:src/stm32f1xx_hal_pwr.c **** 
 390:src/stm32f1xx_hal_pwr.c **** /**
 391:src/stm32f1xx_hal_pwr.c ****   * @brief Disables the WakeUp PINx functionality.
 392:src/stm32f1xx_hal_pwr.c ****   * @param WakeUpPinx: Specifies the Power Wake-Up pin to disable.
 393:src/stm32f1xx_hal_pwr.c ****   *        This parameter can be one of the following values:
 394:src/stm32f1xx_hal_pwr.c ****   *           @arg PWR_WAKEUP_PIN1
 395:src/stm32f1xx_hal_pwr.c ****   * @retval None
 396:src/stm32f1xx_hal_pwr.c ****   */
 397:src/stm32f1xx_hal_pwr.c **** void HAL_PWR_DisableWakeUpPin(uint32_t WakeUpPinx)
 398:src/stm32f1xx_hal_pwr.c **** {
 363              		.loc 1 398 0
 364              		.cfi_startproc
 365              		@ args = 0, pretend = 0, frame = 0
 366              		@ frame_needed = 0, uses_anonymous_args = 0
 367              		@ link register save eliminated.
 368              	.LVL4:
 369              	.LBB8:
 370              	.LBB9:
 371              		.loc 2 988 0
 372              		.syntax unified
 373              	@ 988 "../cmsiscore/inc/cmsis_gcc.h" 1
 374 00d4 90FAA0F0 		rbit r0, r0	@ result, WakeUpPinx
 375              	@ 0 "" 2
 376              	.LVL5:
 377              		.thumb
 378              		.syntax unified
 379              	.LBE9:
 380              	.LBE8:
 399:src/stm32f1xx_hal_pwr.c ****   /* Check the parameter */
ARM GAS  /tmp/cciAnlD7.s 			page 32


 400:src/stm32f1xx_hal_pwr.c ****   assert_param(IS_PWR_WAKEUP_PIN(WakeUpPinx));
 401:src/stm32f1xx_hal_pwr.c ****   /* Disable the EWUPx pin */
 402:src/stm32f1xx_hal_pwr.c ****   *(__IO uint32_t *) CSR_EWUP_BB(WakeUpPinx) = (uint32_t)DISABLE;
 381              		.loc 1 402 0
 382 00d8 B0FA80F0 		clz	r0, r0	@ _3, result
 383 00dc 0022     		movs	r2, #0	@ tmp120,
 384 00de 024B     		ldr	r3, .L40	@ tmp118,
 385 00e0 0344     		add	r3, r3, r0	@ tmp118, _3
 386 00e2 9B00     		lsls	r3, r3, #2	@ _7, tmp118,
 387 00e4 1A60     		str	r2, [r3]	@ tmp120, *_7
 388 00e6 7047     		bx	lr	@
 389              	.L41:
 390              		.align	2
 391              	.L40:
 392 00e8 20808310 		.word	277053472
 393              		.cfi_endproc
 394              	.LFE73:
 395              		.size	HAL_PWR_DisableWakeUpPin, .-HAL_PWR_DisableWakeUpPin
 396              		.align	1
 397              		.global	HAL_PWR_EnterSLEEPMode
 398              		.syntax unified
 399              		.thumb
 400              		.thumb_func
 401              		.fpu softvfp
 402              		.type	HAL_PWR_EnterSLEEPMode, %function
 403              	HAL_PWR_EnterSLEEPMode:
 404              	.LFB74:
 403:src/stm32f1xx_hal_pwr.c **** }
 404:src/stm32f1xx_hal_pwr.c **** 
 405:src/stm32f1xx_hal_pwr.c **** /**
 406:src/stm32f1xx_hal_pwr.c ****   * @brief Enters Sleep mode.
 407:src/stm32f1xx_hal_pwr.c ****   * @note  In Sleep mode, all I/O pins keep the same state as in Run mode.
 408:src/stm32f1xx_hal_pwr.c ****   * @param Regulator: Regulator state as no effect in SLEEP mode -  allows to support portability f
 409:src/stm32f1xx_hal_pwr.c ****   * @param SLEEPEntry: Specifies if SLEEP mode is entered with WFI or WFE instruction.
 410:src/stm32f1xx_hal_pwr.c ****   *           When WFI entry is used, tick interrupt have to be disabled if not desired as 
 411:src/stm32f1xx_hal_pwr.c ****   *           the interrupt wake up source.
 412:src/stm32f1xx_hal_pwr.c ****   *           This parameter can be one of the following values:
 413:src/stm32f1xx_hal_pwr.c ****   *            @arg PWR_SLEEPENTRY_WFI: enter SLEEP mode with WFI instruction
 414:src/stm32f1xx_hal_pwr.c ****   *            @arg PWR_SLEEPENTRY_WFE: enter SLEEP mode with WFE instruction
 415:src/stm32f1xx_hal_pwr.c ****   * @retval None
 416:src/stm32f1xx_hal_pwr.c ****   */
 417:src/stm32f1xx_hal_pwr.c **** void HAL_PWR_EnterSLEEPMode(uint32_t Regulator, uint8_t SLEEPEntry)
 418:src/stm32f1xx_hal_pwr.c **** {
 405              		.loc 1 418 0
 406              		.cfi_startproc
 407              		@ args = 0, pretend = 0, frame = 0
 408              		@ frame_needed = 0, uses_anonymous_args = 0
 409              		@ link register save eliminated.
 410              	.LVL6:
 419:src/stm32f1xx_hal_pwr.c ****   /* Check the parameters */
 420:src/stm32f1xx_hal_pwr.c ****   /* No check on Regulator because parameter not used in SLEEP mode */
 421:src/stm32f1xx_hal_pwr.c ****   /* Prevent unused argument(s) compilation warning */
 422:src/stm32f1xx_hal_pwr.c ****   UNUSED(Regulator);
 423:src/stm32f1xx_hal_pwr.c **** 
 424:src/stm32f1xx_hal_pwr.c ****   assert_param(IS_PWR_SLEEP_ENTRY(SLEEPEntry));
 425:src/stm32f1xx_hal_pwr.c **** 
 426:src/stm32f1xx_hal_pwr.c ****   /* Clear SLEEPDEEP bit of Cortex System Control Register */
ARM GAS  /tmp/cciAnlD7.s 			page 33


 427:src/stm32f1xx_hal_pwr.c ****   CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
 411              		.loc 1 427 0
 412 00ec 064A     		ldr	r2, .L45	@ tmp114,
 428:src/stm32f1xx_hal_pwr.c **** 
 429:src/stm32f1xx_hal_pwr.c ****   /* Select SLEEP mode entry -------------------------------------------------*/
 430:src/stm32f1xx_hal_pwr.c ****   if(SLEEPEntry == PWR_SLEEPENTRY_WFI)
 413              		.loc 1 430 0
 414 00ee 0129     		cmp	r1, #1	@ SLEEPEntry,
 427:src/stm32f1xx_hal_pwr.c **** 
 415              		.loc 1 427 0
 416 00f0 1369     		ldr	r3, [r2, #16]	@ _2, MEM[(struct SCB_Type *)3758157056B].SCR
 417 00f2 23F00403 		bic	r3, r3, #4	@ _3, _2,
 418 00f6 1361     		str	r3, [r2, #16]	@ _3, MEM[(struct SCB_Type *)3758157056B].SCR
 419              		.loc 1 430 0
 420 00f8 01D1     		bne	.L43	@,
 431:src/stm32f1xx_hal_pwr.c ****   {
 432:src/stm32f1xx_hal_pwr.c ****     /* Request Wait For Interrupt */
 433:src/stm32f1xx_hal_pwr.c ****     __WFI();
 421              		.loc 1 433 0
 422              		.syntax unified
 423              	@ 433 "src/stm32f1xx_hal_pwr.c" 1
 424 00fa 30BF     		wfi
 425              	@ 0 "" 2
 426              		.thumb
 427              		.syntax unified
 428 00fc 7047     		bx	lr	@
 429              	.L43:
 434:src/stm32f1xx_hal_pwr.c ****   }
 435:src/stm32f1xx_hal_pwr.c ****   else
 436:src/stm32f1xx_hal_pwr.c ****   {
 437:src/stm32f1xx_hal_pwr.c ****     /* Request Wait For Event */
 438:src/stm32f1xx_hal_pwr.c ****     __SEV();
 430              		.loc 1 438 0
 431              		.syntax unified
 432              	@ 438 "src/stm32f1xx_hal_pwr.c" 1
 433 00fe 40BF     		sev
 434              	@ 0 "" 2
 439:src/stm32f1xx_hal_pwr.c ****     __WFE();
 435              		.loc 1 439 0
 436              	@ 439 "src/stm32f1xx_hal_pwr.c" 1
 437 0100 20BF     		wfe
 438              	@ 0 "" 2
 440:src/stm32f1xx_hal_pwr.c ****     __WFE();
 439              		.loc 1 440 0
 440              	@ 440 "src/stm32f1xx_hal_pwr.c" 1
 441 0102 20BF     		wfe
 442              	@ 0 "" 2
 443              		.thumb
 444              		.syntax unified
 445 0104 7047     		bx	lr	@
 446              	.L46:
 447 0106 00BF     		.align	2
 448              	.L45:
 449 0108 00ED00E0 		.word	-536810240
 450              		.cfi_endproc
 451              	.LFE74:
 452              		.size	HAL_PWR_EnterSLEEPMode, .-HAL_PWR_EnterSLEEPMode
ARM GAS  /tmp/cciAnlD7.s 			page 34


 453              		.align	1
 454              		.global	HAL_PWR_EnterSTOPMode
 455              		.syntax unified
 456              		.thumb
 457              		.thumb_func
 458              		.fpu softvfp
 459              		.type	HAL_PWR_EnterSTOPMode, %function
 460              	HAL_PWR_EnterSTOPMode:
 461              	.LFB75:
 441:src/stm32f1xx_hal_pwr.c ****   }
 442:src/stm32f1xx_hal_pwr.c **** }
 443:src/stm32f1xx_hal_pwr.c **** 
 444:src/stm32f1xx_hal_pwr.c **** /**
 445:src/stm32f1xx_hal_pwr.c ****   * @brief Enters Stop mode. 
 446:src/stm32f1xx_hal_pwr.c ****   * @note  In Stop mode, all I/O pins keep the same state as in Run mode.
 447:src/stm32f1xx_hal_pwr.c ****   * @note  When exiting Stop mode by using an interrupt or a wakeup event,
 448:src/stm32f1xx_hal_pwr.c ****   *        HSI RC oscillator is selected as system clock.
 449:src/stm32f1xx_hal_pwr.c ****   * @note  When the voltage regulator operates in low power mode, an additional
 450:src/stm32f1xx_hal_pwr.c ****   *         startup delay is incurred when waking up from Stop mode. 
 451:src/stm32f1xx_hal_pwr.c ****   *         By keeping the internal regulator ON during Stop mode, the consumption
 452:src/stm32f1xx_hal_pwr.c ****   *         is higher although the startup time is reduced.    
 453:src/stm32f1xx_hal_pwr.c ****   * @param Regulator: Specifies the regulator state in Stop mode.
 454:src/stm32f1xx_hal_pwr.c ****   *          This parameter can be one of the following values:
 455:src/stm32f1xx_hal_pwr.c ****   *            @arg PWR_MAINREGULATOR_ON: Stop mode with regulator ON
 456:src/stm32f1xx_hal_pwr.c ****   *            @arg PWR_LOWPOWERREGULATOR_ON: Stop mode with low power regulator ON
 457:src/stm32f1xx_hal_pwr.c ****   * @param STOPEntry: Specifies if Stop mode in entered with WFI or WFE instruction.
 458:src/stm32f1xx_hal_pwr.c ****   *          This parameter can be one of the following values:
 459:src/stm32f1xx_hal_pwr.c ****   *            @arg PWR_STOPENTRY_WFI: Enter Stop mode with WFI instruction
 460:src/stm32f1xx_hal_pwr.c ****   *            @arg PWR_STOPENTRY_WFE: Enter Stop mode with WFE instruction   
 461:src/stm32f1xx_hal_pwr.c ****   * @retval None
 462:src/stm32f1xx_hal_pwr.c ****   */
 463:src/stm32f1xx_hal_pwr.c **** void HAL_PWR_EnterSTOPMode(uint32_t Regulator, uint8_t STOPEntry)
 464:src/stm32f1xx_hal_pwr.c **** {
 462              		.loc 1 464 0
 463              		.cfi_startproc
 464              		@ args = 0, pretend = 0, frame = 0
 465              		@ frame_needed = 0, uses_anonymous_args = 0
 466              	.LVL7:
 465:src/stm32f1xx_hal_pwr.c ****   /* Check the parameters */
 466:src/stm32f1xx_hal_pwr.c ****   assert_param(IS_PWR_REGULATOR(Regulator));
 467:src/stm32f1xx_hal_pwr.c ****   assert_param(IS_PWR_STOP_ENTRY(STOPEntry));
 468:src/stm32f1xx_hal_pwr.c **** 
 469:src/stm32f1xx_hal_pwr.c ****   /* Clear PDDS bit in PWR register to specify entering in STOP mode when CPU enter in Deepsleep */
 470:src/stm32f1xx_hal_pwr.c ****   CLEAR_BIT(PWR->CR,  PWR_CR_PDDS);
 467              		.loc 1 470 0
 468 010c 0F4A     		ldr	r2, .L50	@ tmp121,
 464:src/stm32f1xx_hal_pwr.c ****   /* Check the parameters */
 469              		.loc 1 464 0
 470 010e 08B5     		push	{r3, lr}	@
 471              	.LCFI0:
 472              		.cfi_def_cfa_offset 8
 473              		.cfi_offset 3, -8
 474              		.cfi_offset 14, -4
 475              		.loc 1 470 0
 476 0110 1368     		ldr	r3, [r2]	@ _3, MEM[(struct PWR_TypeDef *)1073770496B].CR
 471:src/stm32f1xx_hal_pwr.c **** 
 472:src/stm32f1xx_hal_pwr.c ****   /* Select the voltage regulator mode by setting LPDS bit in PWR register according to Regulator p
ARM GAS  /tmp/cciAnlD7.s 			page 35


 473:src/stm32f1xx_hal_pwr.c ****   MODIFY_REG(PWR->CR, PWR_CR_LPDS, Regulator);
 474:src/stm32f1xx_hal_pwr.c **** 
 475:src/stm32f1xx_hal_pwr.c ****   /* Set SLEEPDEEP bit of Cortex System Control Register */
 476:src/stm32f1xx_hal_pwr.c ****   SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
 477:src/stm32f1xx_hal_pwr.c **** 
 478:src/stm32f1xx_hal_pwr.c ****   /* Select Stop mode entry --------------------------------------------------*/
 479:src/stm32f1xx_hal_pwr.c ****   if(STOPEntry == PWR_STOPENTRY_WFI)
 477              		.loc 1 479 0
 478 0112 0129     		cmp	r1, #1	@ STOPEntry,
 470:src/stm32f1xx_hal_pwr.c **** 
 479              		.loc 1 470 0
 480 0114 23F00203 		bic	r3, r3, #2	@ _4, _3,
 481 0118 1360     		str	r3, [r2]	@ _4, MEM[(struct PWR_TypeDef *)1073770496B].CR
 473:src/stm32f1xx_hal_pwr.c **** 
 482              		.loc 1 473 0
 483 011a 1368     		ldr	r3, [r2]	@ _6, MEM[(struct PWR_TypeDef *)1073770496B].CR
 484 011c 23F00103 		bic	r3, r3, #1	@ tmp124, _6,
 485 0120 40EA0300 		orr	r0, r0, r3	@ _9, Regulator, tmp124
 486              	.LVL8:
 476:src/stm32f1xx_hal_pwr.c **** 
 487              		.loc 1 476 0
 488 0124 0A4B     		ldr	r3, .L50+4	@ tmp126,
 473:src/stm32f1xx_hal_pwr.c **** 
 489              		.loc 1 473 0
 490 0126 1060     		str	r0, [r2]	@ _9, MEM[(struct PWR_TypeDef *)1073770496B].CR
 476:src/stm32f1xx_hal_pwr.c **** 
 491              		.loc 1 476 0
 492 0128 1A69     		ldr	r2, [r3, #16]	@ _11, MEM[(struct SCB_Type *)3758157056B].SCR
 493 012a 42F00402 		orr	r2, r2, #4	@ _12, _11,
 494 012e 1A61     		str	r2, [r3, #16]	@ _12, MEM[(struct SCB_Type *)3758157056B].SCR
 495              		.loc 1 479 0
 496 0130 05D1     		bne	.L48	@,
 480:src/stm32f1xx_hal_pwr.c ****   {
 481:src/stm32f1xx_hal_pwr.c ****     /* Request Wait For Interrupt */
 482:src/stm32f1xx_hal_pwr.c ****     __WFI();
 497              		.loc 1 482 0
 498              		.syntax unified
 499              	@ 482 "src/stm32f1xx_hal_pwr.c" 1
 500 0132 30BF     		wfi
 501              	@ 0 "" 2
 502              		.thumb
 503              		.syntax unified
 504              	.L49:
 483:src/stm32f1xx_hal_pwr.c ****   }
 484:src/stm32f1xx_hal_pwr.c ****   else
 485:src/stm32f1xx_hal_pwr.c ****   {
 486:src/stm32f1xx_hal_pwr.c ****     /* Request Wait For Event */
 487:src/stm32f1xx_hal_pwr.c ****     __SEV();
 488:src/stm32f1xx_hal_pwr.c ****     PWR_OverloadWfe(); /* WFE redefine locally */
 489:src/stm32f1xx_hal_pwr.c ****     PWR_OverloadWfe(); /* WFE redefine locally */
 490:src/stm32f1xx_hal_pwr.c ****   }
 491:src/stm32f1xx_hal_pwr.c ****   /* Reset SLEEPDEEP bit of Cortex System Control Register */
 492:src/stm32f1xx_hal_pwr.c ****   CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
 505              		.loc 1 492 0
 506 0134 1A69     		ldr	r2, [r3, #16]	@ _17, MEM[(struct SCB_Type *)3758157056B].SCR
 507 0136 22F00402 		bic	r2, r2, #4	@ _18, _17,
 508 013a 1A61     		str	r2, [r3, #16]	@ _18, MEM[(struct SCB_Type *)3758157056B].SCR
ARM GAS  /tmp/cciAnlD7.s 			page 36


 509 013c 08BD     		pop	{r3, pc}	@
 510              	.L48:
 487:src/stm32f1xx_hal_pwr.c ****     PWR_OverloadWfe(); /* WFE redefine locally */
 511              		.loc 1 487 0
 512              		.syntax unified
 513              	@ 487 "src/stm32f1xx_hal_pwr.c" 1
 514 013e 40BF     		sev
 515              	@ 0 "" 2
 488:src/stm32f1xx_hal_pwr.c ****     PWR_OverloadWfe(); /* WFE redefine locally */
 516              		.loc 1 488 0
 517              		.thumb
 518              		.syntax unified
 519 0140 FFF75EFF 		bl	PWR_OverloadWfe	@
 520              	.LVL9:
 489:src/stm32f1xx_hal_pwr.c ****   }
 521              		.loc 1 489 0
 522 0144 FFF75CFF 		bl	PWR_OverloadWfe	@
 523              	.LVL10:
 524 0148 F4E7     		b	.L49	@
 525              	.L51:
 526 014a 00BF     		.align	2
 527              	.L50:
 528 014c 00700040 		.word	1073770496
 529 0150 00ED00E0 		.word	-536810240
 530              		.cfi_endproc
 531              	.LFE75:
 532              		.size	HAL_PWR_EnterSTOPMode, .-HAL_PWR_EnterSTOPMode
 533              		.align	1
 534              		.global	HAL_PWR_EnterSTANDBYMode
 535              		.syntax unified
 536              		.thumb
 537              		.thumb_func
 538              		.fpu softvfp
 539              		.type	HAL_PWR_EnterSTANDBYMode, %function
 540              	HAL_PWR_EnterSTANDBYMode:
 541              	.LFB76:
 493:src/stm32f1xx_hal_pwr.c **** }
 494:src/stm32f1xx_hal_pwr.c **** 
 495:src/stm32f1xx_hal_pwr.c **** /**
 496:src/stm32f1xx_hal_pwr.c ****   * @brief Enters Standby mode.
 497:src/stm32f1xx_hal_pwr.c ****   * @note  In Standby mode, all I/O pins are high impedance except for:
 498:src/stm32f1xx_hal_pwr.c ****   *          - Reset pad (still available) 
 499:src/stm32f1xx_hal_pwr.c ****   *          - TAMPER pin if configured for tamper or calibration out.
 500:src/stm32f1xx_hal_pwr.c ****   *          - WKUP pin (PA0) if enabled.
 501:src/stm32f1xx_hal_pwr.c ****   * @retval None
 502:src/stm32f1xx_hal_pwr.c ****   */
 503:src/stm32f1xx_hal_pwr.c **** void HAL_PWR_EnterSTANDBYMode(void)
 504:src/stm32f1xx_hal_pwr.c **** {
 542              		.loc 1 504 0
 543              		.cfi_startproc
 544              		@ args = 0, pretend = 0, frame = 0
 545              		@ frame_needed = 0, uses_anonymous_args = 0
 546              		@ link register save eliminated.
 505:src/stm32f1xx_hal_pwr.c ****   /* Select Standby mode */
 506:src/stm32f1xx_hal_pwr.c ****   SET_BIT(PWR->CR, PWR_CR_PDDS);
 547              		.loc 1 506 0
 548 0154 054A     		ldr	r2, .L53	@ tmp114,
ARM GAS  /tmp/cciAnlD7.s 			page 37


 549 0156 1368     		ldr	r3, [r2]	@ _2, MEM[(struct PWR_TypeDef *)1073770496B].CR
 550 0158 43F00203 		orr	r3, r3, #2	@ _3, _2,
 551 015c 1360     		str	r3, [r2]	@ _3, MEM[(struct PWR_TypeDef *)1073770496B].CR
 507:src/stm32f1xx_hal_pwr.c **** 
 508:src/stm32f1xx_hal_pwr.c ****   /* Set SLEEPDEEP bit of Cortex System Control Register */
 509:src/stm32f1xx_hal_pwr.c ****   SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
 552              		.loc 1 509 0
 553 015e 044A     		ldr	r2, .L53+4	@ tmp116,
 554 0160 1369     		ldr	r3, [r2, #16]	@ _5, MEM[(struct SCB_Type *)3758157056B].SCR
 555 0162 43F00403 		orr	r3, r3, #4	@ _6, _5,
 556 0166 1361     		str	r3, [r2, #16]	@ _6, MEM[(struct SCB_Type *)3758157056B].SCR
 510:src/stm32f1xx_hal_pwr.c **** 
 511:src/stm32f1xx_hal_pwr.c ****   /* This option is used to ensure that store operations are completed */
 512:src/stm32f1xx_hal_pwr.c **** #if defined ( __CC_ARM)
 513:src/stm32f1xx_hal_pwr.c ****   __force_stores();
 514:src/stm32f1xx_hal_pwr.c **** #endif
 515:src/stm32f1xx_hal_pwr.c ****   /* Request Wait For Interrupt */
 516:src/stm32f1xx_hal_pwr.c ****   __WFI();
 557              		.loc 1 516 0
 558              		.syntax unified
 559              	@ 516 "src/stm32f1xx_hal_pwr.c" 1
 560 0168 30BF     		wfi
 561              	@ 0 "" 2
 562              		.thumb
 563              		.syntax unified
 564 016a 7047     		bx	lr	@
 565              	.L54:
 566              		.align	2
 567              	.L53:
 568 016c 00700040 		.word	1073770496
 569 0170 00ED00E0 		.word	-536810240
 570              		.cfi_endproc
 571              	.LFE76:
 572              		.size	HAL_PWR_EnterSTANDBYMode, .-HAL_PWR_EnterSTANDBYMode
 573              		.align	1
 574              		.global	HAL_PWR_EnableSleepOnExit
 575              		.syntax unified
 576              		.thumb
 577              		.thumb_func
 578              		.fpu softvfp
 579              		.type	HAL_PWR_EnableSleepOnExit, %function
 580              	HAL_PWR_EnableSleepOnExit:
 581              	.LFB77:
 517:src/stm32f1xx_hal_pwr.c **** }
 518:src/stm32f1xx_hal_pwr.c **** 
 519:src/stm32f1xx_hal_pwr.c **** 
 520:src/stm32f1xx_hal_pwr.c **** /**
 521:src/stm32f1xx_hal_pwr.c ****   * @brief Indicates Sleep-On-Exit when returning from Handler mode to Thread mode. 
 522:src/stm32f1xx_hal_pwr.c ****   * @note Set SLEEPONEXIT bit of SCR register. When this bit is set, the processor 
 523:src/stm32f1xx_hal_pwr.c ****   *       re-enters SLEEP mode when an interruption handling is over.
 524:src/stm32f1xx_hal_pwr.c ****   *       Setting this bit is useful when the processor is expected to run only on
 525:src/stm32f1xx_hal_pwr.c ****   *       interruptions handling.         
 526:src/stm32f1xx_hal_pwr.c ****   * @retval None
 527:src/stm32f1xx_hal_pwr.c ****   */
 528:src/stm32f1xx_hal_pwr.c **** void HAL_PWR_EnableSleepOnExit(void)
 529:src/stm32f1xx_hal_pwr.c **** {
 582              		.loc 1 529 0
ARM GAS  /tmp/cciAnlD7.s 			page 38


 583              		.cfi_startproc
 584              		@ args = 0, pretend = 0, frame = 0
 585              		@ frame_needed = 0, uses_anonymous_args = 0
 586              		@ link register save eliminated.
 530:src/stm32f1xx_hal_pwr.c ****   /* Set SLEEPONEXIT bit of Cortex System Control Register */
 531:src/stm32f1xx_hal_pwr.c ****   SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPONEXIT_Msk));
 587              		.loc 1 531 0
 588 0174 024A     		ldr	r2, .L56	@ tmp112,
 589 0176 1369     		ldr	r3, [r2, #16]	@ _2, MEM[(struct SCB_Type *)3758157056B].SCR
 590 0178 43F00203 		orr	r3, r3, #2	@ _3, _2,
 591 017c 1361     		str	r3, [r2, #16]	@ _3, MEM[(struct SCB_Type *)3758157056B].SCR
 592 017e 7047     		bx	lr	@
 593              	.L57:
 594              		.align	2
 595              	.L56:
 596 0180 00ED00E0 		.word	-536810240
 597              		.cfi_endproc
 598              	.LFE77:
 599              		.size	HAL_PWR_EnableSleepOnExit, .-HAL_PWR_EnableSleepOnExit
 600              		.align	1
 601              		.global	HAL_PWR_DisableSleepOnExit
 602              		.syntax unified
 603              		.thumb
 604              		.thumb_func
 605              		.fpu softvfp
 606              		.type	HAL_PWR_DisableSleepOnExit, %function
 607              	HAL_PWR_DisableSleepOnExit:
 608              	.LFB78:
 532:src/stm32f1xx_hal_pwr.c **** }
 533:src/stm32f1xx_hal_pwr.c **** 
 534:src/stm32f1xx_hal_pwr.c **** 
 535:src/stm32f1xx_hal_pwr.c **** /**
 536:src/stm32f1xx_hal_pwr.c ****   * @brief Disables Sleep-On-Exit feature when returning from Handler mode to Thread mode. 
 537:src/stm32f1xx_hal_pwr.c ****   * @note Clears SLEEPONEXIT bit of SCR register. When this bit is set, the processor 
 538:src/stm32f1xx_hal_pwr.c ****   *       re-enters SLEEP mode when an interruption handling is over.          
 539:src/stm32f1xx_hal_pwr.c ****   * @retval None
 540:src/stm32f1xx_hal_pwr.c ****   */
 541:src/stm32f1xx_hal_pwr.c **** void HAL_PWR_DisableSleepOnExit(void)
 542:src/stm32f1xx_hal_pwr.c **** {
 609              		.loc 1 542 0
 610              		.cfi_startproc
 611              		@ args = 0, pretend = 0, frame = 0
 612              		@ frame_needed = 0, uses_anonymous_args = 0
 613              		@ link register save eliminated.
 543:src/stm32f1xx_hal_pwr.c ****   /* Clear SLEEPONEXIT bit of Cortex System Control Register */
 544:src/stm32f1xx_hal_pwr.c ****   CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPONEXIT_Msk));
 614              		.loc 1 544 0
 615 0184 024A     		ldr	r2, .L59	@ tmp112,
 616 0186 1369     		ldr	r3, [r2, #16]	@ _2, MEM[(struct SCB_Type *)3758157056B].SCR
 617 0188 23F00203 		bic	r3, r3, #2	@ _3, _2,
 618 018c 1361     		str	r3, [r2, #16]	@ _3, MEM[(struct SCB_Type *)3758157056B].SCR
 619 018e 7047     		bx	lr	@
 620              	.L60:
 621              		.align	2
 622              	.L59:
 623 0190 00ED00E0 		.word	-536810240
 624              		.cfi_endproc
ARM GAS  /tmp/cciAnlD7.s 			page 39


 625              	.LFE78:
 626              		.size	HAL_PWR_DisableSleepOnExit, .-HAL_PWR_DisableSleepOnExit
 627              		.align	1
 628              		.global	HAL_PWR_EnableSEVOnPend
 629              		.syntax unified
 630              		.thumb
 631              		.thumb_func
 632              		.fpu softvfp
 633              		.type	HAL_PWR_EnableSEVOnPend, %function
 634              	HAL_PWR_EnableSEVOnPend:
 635              	.LFB79:
 545:src/stm32f1xx_hal_pwr.c **** }
 546:src/stm32f1xx_hal_pwr.c **** 
 547:src/stm32f1xx_hal_pwr.c **** 
 548:src/stm32f1xx_hal_pwr.c **** /**
 549:src/stm32f1xx_hal_pwr.c ****   * @brief Enables CORTEX M3 SEVONPEND bit. 
 550:src/stm32f1xx_hal_pwr.c ****   * @note Sets SEVONPEND bit of SCR register. When this bit is set, this causes 
 551:src/stm32f1xx_hal_pwr.c ****   *       WFE to wake up when an interrupt moves from inactive to pended.
 552:src/stm32f1xx_hal_pwr.c ****   * @retval None
 553:src/stm32f1xx_hal_pwr.c ****   */
 554:src/stm32f1xx_hal_pwr.c **** void HAL_PWR_EnableSEVOnPend(void)
 555:src/stm32f1xx_hal_pwr.c **** {
 636              		.loc 1 555 0
 637              		.cfi_startproc
 638              		@ args = 0, pretend = 0, frame = 0
 639              		@ frame_needed = 0, uses_anonymous_args = 0
 640              		@ link register save eliminated.
 556:src/stm32f1xx_hal_pwr.c ****   /* Set SEVONPEND bit of Cortex System Control Register */
 557:src/stm32f1xx_hal_pwr.c ****   SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SEVONPEND_Msk));
 641              		.loc 1 557 0
 642 0194 024A     		ldr	r2, .L62	@ tmp112,
 643 0196 1369     		ldr	r3, [r2, #16]	@ _2, MEM[(struct SCB_Type *)3758157056B].SCR
 644 0198 43F01003 		orr	r3, r3, #16	@ _3, _2,
 645 019c 1361     		str	r3, [r2, #16]	@ _3, MEM[(struct SCB_Type *)3758157056B].SCR
 646 019e 7047     		bx	lr	@
 647              	.L63:
 648              		.align	2
 649              	.L62:
 650 01a0 00ED00E0 		.word	-536810240
 651              		.cfi_endproc
 652              	.LFE79:
 653              		.size	HAL_PWR_EnableSEVOnPend, .-HAL_PWR_EnableSEVOnPend
 654              		.align	1
 655              		.global	HAL_PWR_DisableSEVOnPend
 656              		.syntax unified
 657              		.thumb
 658              		.thumb_func
 659              		.fpu softvfp
 660              		.type	HAL_PWR_DisableSEVOnPend, %function
 661              	HAL_PWR_DisableSEVOnPend:
 662              	.LFB80:
 558:src/stm32f1xx_hal_pwr.c **** }
 559:src/stm32f1xx_hal_pwr.c **** 
 560:src/stm32f1xx_hal_pwr.c **** 
 561:src/stm32f1xx_hal_pwr.c **** /**
 562:src/stm32f1xx_hal_pwr.c ****   * @brief Disables CORTEX M3 SEVONPEND bit. 
 563:src/stm32f1xx_hal_pwr.c ****   * @note Clears SEVONPEND bit of SCR register. When this bit is set, this causes 
ARM GAS  /tmp/cciAnlD7.s 			page 40


 564:src/stm32f1xx_hal_pwr.c ****   *       WFE to wake up when an interrupt moves from inactive to pended.         
 565:src/stm32f1xx_hal_pwr.c ****   * @retval None
 566:src/stm32f1xx_hal_pwr.c ****   */
 567:src/stm32f1xx_hal_pwr.c **** void HAL_PWR_DisableSEVOnPend(void)
 568:src/stm32f1xx_hal_pwr.c **** {
 663              		.loc 1 568 0
 664              		.cfi_startproc
 665              		@ args = 0, pretend = 0, frame = 0
 666              		@ frame_needed = 0, uses_anonymous_args = 0
 667              		@ link register save eliminated.
 569:src/stm32f1xx_hal_pwr.c ****   /* Clear SEVONPEND bit of Cortex System Control Register */
 570:src/stm32f1xx_hal_pwr.c ****   CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SEVONPEND_Msk));
 668              		.loc 1 570 0
 669 01a4 024A     		ldr	r2, .L65	@ tmp112,
 670 01a6 1369     		ldr	r3, [r2, #16]	@ _2, MEM[(struct SCB_Type *)3758157056B].SCR
 671 01a8 23F01003 		bic	r3, r3, #16	@ _3, _2,
 672 01ac 1361     		str	r3, [r2, #16]	@ _3, MEM[(struct SCB_Type *)3758157056B].SCR
 673 01ae 7047     		bx	lr	@
 674              	.L66:
 675              		.align	2
 676              	.L65:
 677 01b0 00ED00E0 		.word	-536810240
 678              		.cfi_endproc
 679              	.LFE80:
 680              		.size	HAL_PWR_DisableSEVOnPend, .-HAL_PWR_DisableSEVOnPend
 681              		.align	1
 682              		.weak	HAL_PWR_PVDCallback
 683              		.syntax unified
 684              		.thumb
 685              		.thumb_func
 686              		.fpu softvfp
 687              		.type	HAL_PWR_PVDCallback, %function
 688              	HAL_PWR_PVDCallback:
 689              	.LFB82:
 571:src/stm32f1xx_hal_pwr.c **** }
 572:src/stm32f1xx_hal_pwr.c **** 
 573:src/stm32f1xx_hal_pwr.c **** 
 574:src/stm32f1xx_hal_pwr.c **** 
 575:src/stm32f1xx_hal_pwr.c **** /**
 576:src/stm32f1xx_hal_pwr.c ****   * @brief  This function handles the PWR PVD interrupt request.
 577:src/stm32f1xx_hal_pwr.c ****   * @note   This API should be called under the PVD_IRQHandler().
 578:src/stm32f1xx_hal_pwr.c ****   * @retval None
 579:src/stm32f1xx_hal_pwr.c ****   */
 580:src/stm32f1xx_hal_pwr.c **** void HAL_PWR_PVD_IRQHandler(void)
 581:src/stm32f1xx_hal_pwr.c **** {
 582:src/stm32f1xx_hal_pwr.c ****   /* Check PWR exti flag */
 583:src/stm32f1xx_hal_pwr.c ****   if(__HAL_PWR_PVD_EXTI_GET_FLAG() != RESET)
 584:src/stm32f1xx_hal_pwr.c ****   {
 585:src/stm32f1xx_hal_pwr.c ****     /* PWR PVD interrupt user callback */
 586:src/stm32f1xx_hal_pwr.c ****     HAL_PWR_PVDCallback();
 587:src/stm32f1xx_hal_pwr.c **** 
 588:src/stm32f1xx_hal_pwr.c ****     /* Clear PWR Exti pending bit */
 589:src/stm32f1xx_hal_pwr.c ****     __HAL_PWR_PVD_EXTI_CLEAR_FLAG();
 590:src/stm32f1xx_hal_pwr.c ****   }
 591:src/stm32f1xx_hal_pwr.c **** }
 592:src/stm32f1xx_hal_pwr.c **** 
 593:src/stm32f1xx_hal_pwr.c **** /**
ARM GAS  /tmp/cciAnlD7.s 			page 41


 594:src/stm32f1xx_hal_pwr.c ****   * @brief  PWR PVD interrupt callback
 595:src/stm32f1xx_hal_pwr.c ****   * @retval None
 596:src/stm32f1xx_hal_pwr.c ****   */
 597:src/stm32f1xx_hal_pwr.c **** __weak void HAL_PWR_PVDCallback(void)
 598:src/stm32f1xx_hal_pwr.c **** {
 690              		.loc 1 598 0
 691              		.cfi_startproc
 692              		@ args = 0, pretend = 0, frame = 0
 693              		@ frame_needed = 0, uses_anonymous_args = 0
 694              		@ link register save eliminated.
 695 01b4 7047     		bx	lr	@
 696              		.cfi_endproc
 697              	.LFE82:
 698              		.size	HAL_PWR_PVDCallback, .-HAL_PWR_PVDCallback
 699              		.align	1
 700              		.global	HAL_PWR_PVD_IRQHandler
 701              		.syntax unified
 702              		.thumb
 703              		.thumb_func
 704              		.fpu softvfp
 705              		.type	HAL_PWR_PVD_IRQHandler, %function
 706              	HAL_PWR_PVD_IRQHandler:
 707              	.LFB81:
 581:src/stm32f1xx_hal_pwr.c ****   /* Check PWR exti flag */
 708              		.loc 1 581 0
 709              		.cfi_startproc
 710              		@ args = 0, pretend = 0, frame = 0
 711              		@ frame_needed = 0, uses_anonymous_args = 0
 581:src/stm32f1xx_hal_pwr.c ****   /* Check PWR exti flag */
 712              		.loc 1 581 0
 713 01b6 10B5     		push	{r4, lr}	@
 714              	.LCFI1:
 715              		.cfi_def_cfa_offset 8
 716              		.cfi_offset 4, -8
 717              		.cfi_offset 14, -4
 583:src/stm32f1xx_hal_pwr.c ****   {
 718              		.loc 1 583 0
 719 01b8 044C     		ldr	r4, .L73	@ tmp112,
 720 01ba 6369     		ldr	r3, [r4, #20]	@ _3, MEM[(struct EXTI_TypeDef *)1073808384B].PR
 721 01bc DB03     		lsls	r3, r3, #15	@, _3,
 722 01be 04D5     		bpl	.L68	@,
 586:src/stm32f1xx_hal_pwr.c **** 
 723              		.loc 1 586 0
 724 01c0 FFF7FEFF 		bl	HAL_PWR_PVDCallback	@
 725              	.LVL11:
 589:src/stm32f1xx_hal_pwr.c ****   }
 726              		.loc 1 589 0
 727 01c4 4FF48033 		mov	r3, #65536	@ tmp115,
 728 01c8 6361     		str	r3, [r4, #20]	@ tmp115, MEM[(struct EXTI_TypeDef *)1073808384B].PR
 729              	.L68:
 730 01ca 10BD     		pop	{r4, pc}	@
 731              	.L74:
 732              		.align	2
 733              	.L73:
 734 01cc 00040140 		.word	1073808384
 735              		.cfi_endproc
 736              	.LFE81:
ARM GAS  /tmp/cciAnlD7.s 			page 42


 737              		.size	HAL_PWR_PVD_IRQHandler, .-HAL_PWR_PVD_IRQHandler
 738              	.Letext0:
 739              		.file 3 "/usr/include/newlib/machine/_default_types.h"
 740              		.file 4 "/usr/include/newlib/sys/_stdint.h"
 741              		.file 5 "../cmsiscore/inc/core_cm3.h"
 742              		.file 6 "../cmsisstm32f1xx/inc/system_stm32f1xx.h"
 743              		.file 7 "../cmsisstm32f1xx/inc/stm32f103x6.h"
 744              		.file 8 "../cmsisstm32f1xx/inc/stm32f1xx.h"
 745              		.file 9 "./inc/stm32f1xx_hal_pwr.h"
 746              		.file 10 "./inc/stm32f1xx_hal.h"
 747              		.section	.debug_info,"",%progbits
 748              	.Ldebug_info0:
 749 0000 99070000 		.4byte	0x799
 750 0004 0200     		.2byte	0x2
 751 0006 00000000 		.4byte	.Ldebug_abbrev0
 752 000a 04       		.byte	0x4
 753 000b 01       		.uleb128 0x1
 754 000c 99000000 		.4byte	.LASF85
 755 0010 0C       		.byte	0xc
 756 0011 0F010000 		.4byte	.LASF86
 757 0015 A6020000 		.4byte	.LASF87
 758 0019 00000000 		.4byte	.Ltext0
 759 001d D0010000 		.4byte	.Letext0
 760 0021 00000000 		.4byte	.Ldebug_line0
 761 0025 02       		.uleb128 0x2
 762 0026 01       		.byte	0x1
 763 0027 06       		.byte	0x6
 764 0028 05030000 		.4byte	.LASF0
 765 002c 03       		.uleb128 0x3
 766 002d 45020000 		.4byte	.LASF4
 767 0031 03       		.byte	0x3
 768 0032 1D       		.byte	0x1d
 769 0033 37000000 		.4byte	0x37
 770 0037 02       		.uleb128 0x2
 771 0038 01       		.byte	0x1
 772 0039 08       		.byte	0x8
 773 003a 98020000 		.4byte	.LASF1
 774 003e 02       		.uleb128 0x2
 775 003f 02       		.byte	0x2
 776 0040 05       		.byte	0x5
 777 0041 68010000 		.4byte	.LASF2
 778 0045 02       		.uleb128 0x2
 779 0046 02       		.byte	0x2
 780 0047 07       		.byte	0x7
 781 0048 6E030000 		.4byte	.LASF3
 782 004c 03       		.uleb128 0x3
 783 004d 72040000 		.4byte	.LASF5
 784 0051 03       		.byte	0x3
 785 0052 3F       		.byte	0x3f
 786 0053 57000000 		.4byte	0x57
 787 0057 02       		.uleb128 0x2
 788 0058 04       		.byte	0x4
 789 0059 05       		.byte	0x5
 790 005a ED010000 		.4byte	.LASF6
 791 005e 03       		.uleb128 0x3
 792 005f 62040000 		.4byte	.LASF7
 793 0063 03       		.byte	0x3
ARM GAS  /tmp/cciAnlD7.s 			page 43


 794 0064 41       		.byte	0x41
 795 0065 69000000 		.4byte	0x69
 796 0069 02       		.uleb128 0x2
 797 006a 04       		.byte	0x4
 798 006b 07       		.byte	0x7
 799 006c 50040000 		.4byte	.LASF8
 800 0070 02       		.uleb128 0x2
 801 0071 08       		.byte	0x8
 802 0072 05       		.byte	0x5
 803 0073 63000000 		.4byte	.LASF9
 804 0077 02       		.uleb128 0x2
 805 0078 08       		.byte	0x8
 806 0079 07       		.byte	0x7
 807 007a 11030000 		.4byte	.LASF10
 808 007e 04       		.uleb128 0x4
 809 007f 04       		.byte	0x4
 810 0080 05       		.byte	0x5
 811 0081 696E7400 		.ascii	"int\000"
 812 0085 02       		.uleb128 0x2
 813 0086 04       		.byte	0x4
 814 0087 07       		.byte	0x7
 815 0088 39030000 		.4byte	.LASF11
 816 008c 03       		.uleb128 0x3
 817 008d 27010000 		.4byte	.LASF12
 818 0091 04       		.byte	0x4
 819 0092 18       		.byte	0x18
 820 0093 2C000000 		.4byte	0x2c
 821 0097 05       		.uleb128 0x5
 822 0098 8C000000 		.4byte	0x8c
 823 009c 06       		.uleb128 0x6
 824 009d 8C000000 		.4byte	0x8c
 825 00a1 03       		.uleb128 0x3
 826 00a2 9D030000 		.4byte	.LASF13
 827 00a6 04       		.byte	0x4
 828 00a7 2C       		.byte	0x2c
 829 00a8 4C000000 		.4byte	0x4c
 830 00ac 05       		.uleb128 0x5
 831 00ad A1000000 		.4byte	0xa1
 832 00b1 03       		.uleb128 0x3
 833 00b2 47040000 		.4byte	.LASF14
 834 00b6 04       		.byte	0x4
 835 00b7 30       		.byte	0x30
 836 00b8 5E000000 		.4byte	0x5e
 837 00bc 05       		.uleb128 0x5
 838 00bd B1000000 		.4byte	0xb1
 839 00c1 06       		.uleb128 0x6
 840 00c2 BC000000 		.4byte	0xbc
 841 00c6 02       		.uleb128 0x2
 842 00c7 04       		.byte	0x4
 843 00c8 07       		.byte	0x7
 844 00c9 49000000 		.4byte	.LASF15
 845 00cd 07       		.uleb128 0x7
 846 00ce 8C       		.byte	0x8c
 847 00cf 05       		.byte	0x5
 848 00d0 7601     		.2byte	0x176
 849 00d2 13020000 		.4byte	0x213
 850 00d6 08       		.uleb128 0x8
ARM GAS  /tmp/cciAnlD7.s 			page 44


 851 00d7 93000000 		.4byte	.LASF16
 852 00db 05       		.byte	0x5
 853 00dc 7801     		.2byte	0x178
 854 00de C1000000 		.4byte	0xc1
 855 00e2 02       		.byte	0x2
 856 00e3 23       		.byte	0x23
 857 00e4 00       		.uleb128 0
 858 00e5 08       		.uleb128 0x8
 859 00e6 72010000 		.4byte	.LASF17
 860 00ea 05       		.byte	0x5
 861 00eb 7901     		.2byte	0x179
 862 00ed BC000000 		.4byte	0xbc
 863 00f1 02       		.byte	0x2
 864 00f2 23       		.byte	0x23
 865 00f3 04       		.uleb128 0x4
 866 00f4 08       		.uleb128 0x8
 867 00f5 98030000 		.4byte	.LASF18
 868 00f9 05       		.byte	0x5
 869 00fa 7A01     		.2byte	0x17a
 870 00fc BC000000 		.4byte	0xbc
 871 0100 02       		.byte	0x2
 872 0101 23       		.byte	0x23
 873 0102 08       		.uleb128 0x8
 874 0103 08       		.uleb128 0x8
 875 0104 92020000 		.4byte	.LASF19
 876 0108 05       		.byte	0x5
 877 0109 7B01     		.2byte	0x17b
 878 010b BC000000 		.4byte	0xbc
 879 010f 02       		.byte	0x2
 880 0110 23       		.byte	0x23
 881 0111 0C       		.uleb128 0xc
 882 0112 09       		.uleb128 0x9
 883 0113 53435200 		.ascii	"SCR\000"
 884 0117 05       		.byte	0x5
 885 0118 7C01     		.2byte	0x17c
 886 011a BC000000 		.4byte	0xbc
 887 011e 02       		.byte	0x2
 888 011f 23       		.byte	0x23
 889 0120 10       		.uleb128 0x10
 890 0121 09       		.uleb128 0x9
 891 0122 43435200 		.ascii	"CCR\000"
 892 0126 05       		.byte	0x5
 893 0127 7D01     		.2byte	0x17d
 894 0129 BC000000 		.4byte	0xbc
 895 012d 02       		.byte	0x2
 896 012e 23       		.byte	0x23
 897 012f 14       		.uleb128 0x14
 898 0130 09       		.uleb128 0x9
 899 0131 53485000 		.ascii	"SHP\000"
 900 0135 05       		.byte	0x5
 901 0136 7E01     		.2byte	0x17e
 902 0138 23020000 		.4byte	0x223
 903 013c 02       		.byte	0x2
 904 013d 23       		.byte	0x23
 905 013e 18       		.uleb128 0x18
 906 013f 08       		.uleb128 0x8
 907 0140 28030000 		.4byte	.LASF20
ARM GAS  /tmp/cciAnlD7.s 			page 45


 908 0144 05       		.byte	0x5
 909 0145 7F01     		.2byte	0x17f
 910 0147 BC000000 		.4byte	0xbc
 911 014b 02       		.byte	0x2
 912 014c 23       		.byte	0x23
 913 014d 24       		.uleb128 0x24
 914 014e 08       		.uleb128 0x8
 915 014f 62020000 		.4byte	.LASF21
 916 0153 05       		.byte	0x5
 917 0154 8001     		.2byte	0x180
 918 0156 BC000000 		.4byte	0xbc
 919 015a 02       		.byte	0x2
 920 015b 23       		.byte	0x23
 921 015c 28       		.uleb128 0x28
 922 015d 08       		.uleb128 0x8
 923 015e 20040000 		.4byte	.LASF22
 924 0162 05       		.byte	0x5
 925 0163 8101     		.2byte	0x181
 926 0165 BC000000 		.4byte	0xbc
 927 0169 02       		.byte	0x2
 928 016a 23       		.byte	0x23
 929 016b 2C       		.uleb128 0x2c
 930 016c 08       		.uleb128 0x8
 931 016d C4030000 		.4byte	.LASF23
 932 0171 05       		.byte	0x5
 933 0172 8201     		.2byte	0x182
 934 0174 BC000000 		.4byte	0xbc
 935 0178 02       		.byte	0x2
 936 0179 23       		.byte	0x23
 937 017a 30       		.uleb128 0x30
 938 017b 08       		.uleb128 0x8
 939 017c 29000000 		.4byte	.LASF24
 940 0180 05       		.byte	0x5
 941 0181 8301     		.2byte	0x183
 942 0183 BC000000 		.4byte	0xbc
 943 0187 02       		.byte	0x2
 944 0188 23       		.byte	0x23
 945 0189 34       		.uleb128 0x34
 946 018a 08       		.uleb128 0x8
 947 018b 0A010000 		.4byte	.LASF25
 948 018f 05       		.byte	0x5
 949 0190 8401     		.2byte	0x184
 950 0192 BC000000 		.4byte	0xbc
 951 0196 02       		.byte	0x2
 952 0197 23       		.byte	0x23
 953 0198 38       		.uleb128 0x38
 954 0199 08       		.uleb128 0x8
 955 019a A0040000 		.4byte	.LASF26
 956 019e 05       		.byte	0x5
 957 019f 8501     		.2byte	0x185
 958 01a1 BC000000 		.4byte	0xbc
 959 01a5 02       		.byte	0x2
 960 01a6 23       		.byte	0x23
 961 01a7 3C       		.uleb128 0x3c
 962 01a8 09       		.uleb128 0x9
 963 01a9 50465200 		.ascii	"PFR\000"
 964 01ad 05       		.byte	0x5
ARM GAS  /tmp/cciAnlD7.s 			page 46


 965 01ae 8601     		.2byte	0x186
 966 01b0 3D020000 		.4byte	0x23d
 967 01b4 02       		.byte	0x2
 968 01b5 23       		.byte	0x23
 969 01b6 40       		.uleb128 0x40
 970 01b7 09       		.uleb128 0x9
 971 01b8 44465200 		.ascii	"DFR\000"
 972 01bc 05       		.byte	0x5
 973 01bd 8701     		.2byte	0x187
 974 01bf C1000000 		.4byte	0xc1
 975 01c3 02       		.byte	0x2
 976 01c4 23       		.byte	0x23
 977 01c5 48       		.uleb128 0x48
 978 01c6 09       		.uleb128 0x9
 979 01c7 41445200 		.ascii	"ADR\000"
 980 01cb 05       		.byte	0x5
 981 01cc 8801     		.2byte	0x188
 982 01ce C1000000 		.4byte	0xc1
 983 01d2 02       		.byte	0x2
 984 01d3 23       		.byte	0x23
 985 01d4 4C       		.uleb128 0x4c
 986 01d5 08       		.uleb128 0x8
 987 01d6 82040000 		.4byte	.LASF27
 988 01da 05       		.byte	0x5
 989 01db 8901     		.2byte	0x189
 990 01dd 57020000 		.4byte	0x257
 991 01e1 02       		.byte	0x2
 992 01e2 23       		.byte	0x23
 993 01e3 50       		.uleb128 0x50
 994 01e4 08       		.uleb128 0x8
 995 01e5 A5030000 		.4byte	.LASF28
 996 01e9 05       		.byte	0x5
 997 01ea 8A01     		.2byte	0x18a
 998 01ec 71020000 		.4byte	0x271
 999 01f0 02       		.byte	0x2
 1000 01f1 23       		.byte	0x23
 1001 01f2 60       		.uleb128 0x60
 1002 01f3 08       		.uleb128 0x8
 1003 01f4 3D040000 		.4byte	.LASF29
 1004 01f8 05       		.byte	0x5
 1005 01f9 8B01     		.2byte	0x18b
 1006 01fb 76020000 		.4byte	0x276
 1007 01ff 02       		.byte	0x2
 1008 0200 23       		.byte	0x23
 1009 0201 74       		.uleb128 0x74
 1010 0202 08       		.uleb128 0x8
 1011 0203 C6040000 		.4byte	.LASF30
 1012 0207 05       		.byte	0x5
 1013 0208 8C01     		.2byte	0x18c
 1014 020a BC000000 		.4byte	0xbc
 1015 020e 03       		.byte	0x3
 1016 020f 23       		.byte	0x23
 1017 0210 8801     		.uleb128 0x88
 1018 0212 00       		.byte	0
 1019 0213 0A       		.uleb128 0xa
 1020 0214 97000000 		.4byte	0x97
 1021 0218 23020000 		.4byte	0x223
ARM GAS  /tmp/cciAnlD7.s 			page 47


 1022 021c 0B       		.uleb128 0xb
 1023 021d C6000000 		.4byte	0xc6
 1024 0221 0B       		.byte	0xb
 1025 0222 00       		.byte	0
 1026 0223 05       		.uleb128 0x5
 1027 0224 13020000 		.4byte	0x213
 1028 0228 0A       		.uleb128 0xa
 1029 0229 C1000000 		.4byte	0xc1
 1030 022d 38020000 		.4byte	0x238
 1031 0231 0B       		.uleb128 0xb
 1032 0232 C6000000 		.4byte	0xc6
 1033 0236 01       		.byte	0x1
 1034 0237 00       		.byte	0
 1035 0238 06       		.uleb128 0x6
 1036 0239 28020000 		.4byte	0x228
 1037 023d 05       		.uleb128 0x5
 1038 023e 38020000 		.4byte	0x238
 1039 0242 0A       		.uleb128 0xa
 1040 0243 C1000000 		.4byte	0xc1
 1041 0247 52020000 		.4byte	0x252
 1042 024b 0B       		.uleb128 0xb
 1043 024c C6000000 		.4byte	0xc6
 1044 0250 03       		.byte	0x3
 1045 0251 00       		.byte	0
 1046 0252 06       		.uleb128 0x6
 1047 0253 42020000 		.4byte	0x242
 1048 0257 05       		.uleb128 0x5
 1049 0258 52020000 		.4byte	0x252
 1050 025c 0A       		.uleb128 0xa
 1051 025d C1000000 		.4byte	0xc1
 1052 0261 6C020000 		.4byte	0x26c
 1053 0265 0B       		.uleb128 0xb
 1054 0266 C6000000 		.4byte	0xc6
 1055 026a 04       		.byte	0x4
 1056 026b 00       		.byte	0
 1057 026c 06       		.uleb128 0x6
 1058 026d 5C020000 		.4byte	0x25c
 1059 0271 05       		.uleb128 0x5
 1060 0272 6C020000 		.4byte	0x26c
 1061 0276 0A       		.uleb128 0xa
 1062 0277 B1000000 		.4byte	0xb1
 1063 027b 86020000 		.4byte	0x286
 1064 027f 0B       		.uleb128 0xb
 1065 0280 C6000000 		.4byte	0xc6
 1066 0284 04       		.byte	0x4
 1067 0285 00       		.byte	0
 1068 0286 0C       		.uleb128 0xc
 1069 0287 2F010000 		.4byte	.LASF31
 1070 028b 05       		.byte	0x5
 1071 028c 8D01     		.2byte	0x18d
 1072 028e CD000000 		.4byte	0xcd
 1073 0292 0D       		.uleb128 0xd
 1074 0293 A5040000 		.4byte	.LASF32
 1075 0297 05       		.byte	0x5
 1076 0298 4807     		.2byte	0x748
 1077 029a AC000000 		.4byte	0xac
 1078 029e 01       		.byte	0x1
ARM GAS  /tmp/cciAnlD7.s 			page 48


 1079 029f 01       		.byte	0x1
 1080 02a0 0E       		.uleb128 0xe
 1081 02a1 E9030000 		.4byte	.LASF33
 1082 02a5 06       		.byte	0x6
 1083 02a6 33       		.byte	0x33
 1084 02a7 B1000000 		.4byte	0xb1
 1085 02ab 01       		.byte	0x1
 1086 02ac 01       		.byte	0x1
 1087 02ad 0A       		.uleb128 0xa
 1088 02ae 9C000000 		.4byte	0x9c
 1089 02b2 BD020000 		.4byte	0x2bd
 1090 02b6 0B       		.uleb128 0xb
 1091 02b7 C6000000 		.4byte	0xc6
 1092 02bb 0F       		.byte	0xf
 1093 02bc 00       		.byte	0
 1094 02bd 06       		.uleb128 0x6
 1095 02be AD020000 		.4byte	0x2ad
 1096 02c2 0E       		.uleb128 0xe
 1097 02c3 40010000 		.4byte	.LASF34
 1098 02c7 06       		.byte	0x6
 1099 02c8 34       		.byte	0x34
 1100 02c9 BD020000 		.4byte	0x2bd
 1101 02cd 01       		.byte	0x1
 1102 02ce 01       		.byte	0x1
 1103 02cf 0A       		.uleb128 0xa
 1104 02d0 9C000000 		.4byte	0x9c
 1105 02d4 DF020000 		.4byte	0x2df
 1106 02d8 0B       		.uleb128 0xb
 1107 02d9 C6000000 		.4byte	0xc6
 1108 02dd 07       		.byte	0x7
 1109 02de 00       		.byte	0
 1110 02df 06       		.uleb128 0x6
 1111 02e0 CF020000 		.4byte	0x2cf
 1112 02e4 0E       		.uleb128 0xe
 1113 02e5 6E020000 		.4byte	.LASF35
 1114 02e9 06       		.byte	0x6
 1115 02ea 35       		.byte	0x35
 1116 02eb DF020000 		.4byte	0x2df
 1117 02ef 01       		.byte	0x1
 1118 02f0 01       		.byte	0x1
 1119 02f1 07       		.uleb128 0x7
 1120 02f2 18       		.byte	0x18
 1121 02f3 07       		.byte	0x7
 1122 02f4 3201     		.2byte	0x132
 1123 02f6 54030000 		.4byte	0x354
 1124 02fa 09       		.uleb128 0x9
 1125 02fb 494D5200 		.ascii	"IMR\000"
 1126 02ff 07       		.byte	0x7
 1127 0300 3401     		.2byte	0x134
 1128 0302 BC000000 		.4byte	0xbc
 1129 0306 02       		.byte	0x2
 1130 0307 23       		.byte	0x23
 1131 0308 00       		.uleb128 0
 1132 0309 09       		.uleb128 0x9
 1133 030a 454D5200 		.ascii	"EMR\000"
 1134 030e 07       		.byte	0x7
 1135 030f 3501     		.2byte	0x135
ARM GAS  /tmp/cciAnlD7.s 			page 49


 1136 0311 BC000000 		.4byte	0xbc
 1137 0315 02       		.byte	0x2
 1138 0316 23       		.byte	0x23
 1139 0317 04       		.uleb128 0x4
 1140 0318 08       		.uleb128 0x8
 1141 0319 E4030000 		.4byte	.LASF36
 1142 031d 07       		.byte	0x7
 1143 031e 3601     		.2byte	0x136
 1144 0320 BC000000 		.4byte	0xbc
 1145 0324 02       		.byte	0x2
 1146 0325 23       		.byte	0x23
 1147 0326 08       		.uleb128 0x8
 1148 0327 08       		.uleb128 0x8
 1149 0328 51030000 		.4byte	.LASF37
 1150 032c 07       		.byte	0x7
 1151 032d 3701     		.2byte	0x137
 1152 032f BC000000 		.4byte	0xbc
 1153 0333 02       		.byte	0x2
 1154 0334 23       		.byte	0x23
 1155 0335 0C       		.uleb128 0xc
 1156 0336 08       		.uleb128 0x8
 1157 0337 E9040000 		.4byte	.LASF38
 1158 033b 07       		.byte	0x7
 1159 033c 3801     		.2byte	0x138
 1160 033e BC000000 		.4byte	0xbc
 1161 0342 02       		.byte	0x2
 1162 0343 23       		.byte	0x23
 1163 0344 10       		.uleb128 0x10
 1164 0345 09       		.uleb128 0x9
 1165 0346 505200   		.ascii	"PR\000"
 1166 0349 07       		.byte	0x7
 1167 034a 3901     		.2byte	0x139
 1168 034c BC000000 		.4byte	0xbc
 1169 0350 02       		.byte	0x2
 1170 0351 23       		.byte	0x23
 1171 0352 14       		.uleb128 0x14
 1172 0353 00       		.byte	0
 1173 0354 0C       		.uleb128 0xc
 1174 0355 E0010000 		.4byte	.LASF39
 1175 0359 07       		.byte	0x7
 1176 035a 3A01     		.2byte	0x13a
 1177 035c F1020000 		.4byte	0x2f1
 1178 0360 07       		.uleb128 0x7
 1179 0361 08       		.byte	0x8
 1180 0362 07       		.byte	0x7
 1181 0363 9901     		.2byte	0x199
 1182 0365 87030000 		.4byte	0x387
 1183 0369 09       		.uleb128 0x9
 1184 036a 435200   		.ascii	"CR\000"
 1185 036d 07       		.byte	0x7
 1186 036e 9B01     		.2byte	0x19b
 1187 0370 BC000000 		.4byte	0xbc
 1188 0374 02       		.byte	0x2
 1189 0375 23       		.byte	0x23
 1190 0376 00       		.uleb128 0
 1191 0377 09       		.uleb128 0x9
 1192 0378 43535200 		.ascii	"CSR\000"
ARM GAS  /tmp/cciAnlD7.s 			page 50


 1193 037c 07       		.byte	0x7
 1194 037d 9C01     		.2byte	0x19c
 1195 037f BC000000 		.4byte	0xbc
 1196 0383 02       		.byte	0x2
 1197 0384 23       		.byte	0x23
 1198 0385 04       		.uleb128 0x4
 1199 0386 00       		.byte	0
 1200 0387 0C       		.uleb128 0xc
 1201 0388 57000000 		.4byte	.LASF40
 1202 038c 07       		.byte	0x7
 1203 038d 9D01     		.2byte	0x19d
 1204 038f 60030000 		.4byte	0x360
 1205 0393 07       		.uleb128 0x7
 1206 0394 28       		.byte	0x28
 1207 0395 07       		.byte	0x7
 1208 0396 A301     		.2byte	0x1a3
 1209 0398 32040000 		.4byte	0x432
 1210 039c 09       		.uleb128 0x9
 1211 039d 435200   		.ascii	"CR\000"
 1212 03a0 07       		.byte	0x7
 1213 03a1 A501     		.2byte	0x1a5
 1214 03a3 BC000000 		.4byte	0xbc
 1215 03a7 02       		.byte	0x2
 1216 03a8 23       		.byte	0x23
 1217 03a9 00       		.uleb128 0
 1218 03aa 08       		.uleb128 0x8
 1219 03ab 56030000 		.4byte	.LASF41
 1220 03af 07       		.byte	0x7
 1221 03b0 A601     		.2byte	0x1a6
 1222 03b2 BC000000 		.4byte	0xbc
 1223 03b6 02       		.byte	0x2
 1224 03b7 23       		.byte	0x23
 1225 03b8 04       		.uleb128 0x4
 1226 03b9 09       		.uleb128 0x9
 1227 03ba 43495200 		.ascii	"CIR\000"
 1228 03be 07       		.byte	0x7
 1229 03bf A701     		.2byte	0x1a7
 1230 03c1 BC000000 		.4byte	0xbc
 1231 03c5 02       		.byte	0x2
 1232 03c6 23       		.byte	0x23
 1233 03c7 08       		.uleb128 0x8
 1234 03c8 08       		.uleb128 0x8
 1235 03c9 3C020000 		.4byte	.LASF42
 1236 03cd 07       		.byte	0x7
 1237 03ce A801     		.2byte	0x1a8
 1238 03d0 BC000000 		.4byte	0xbc
 1239 03d4 02       		.byte	0x2
 1240 03d5 23       		.byte	0x23
 1241 03d6 0C       		.uleb128 0xc
 1242 03d7 08       		.uleb128 0x8
 1243 03d8 8A000000 		.4byte	.LASF43
 1244 03dc 07       		.byte	0x7
 1245 03dd A901     		.2byte	0x1a9
 1246 03df BC000000 		.4byte	0xbc
 1247 03e3 02       		.byte	0x2
 1248 03e4 23       		.byte	0x23
 1249 03e5 10       		.uleb128 0x10
ARM GAS  /tmp/cciAnlD7.s 			page 51


 1250 03e6 08       		.uleb128 0x8
 1251 03e7 35020000 		.4byte	.LASF44
 1252 03eb 07       		.byte	0x7
 1253 03ec AA01     		.2byte	0x1aa
 1254 03ee BC000000 		.4byte	0xbc
 1255 03f2 02       		.byte	0x2
 1256 03f3 23       		.byte	0x23
 1257 03f4 14       		.uleb128 0x14
 1258 03f5 08       		.uleb128 0x8
 1259 03f6 D2020000 		.4byte	.LASF45
 1260 03fa 07       		.byte	0x7
 1261 03fb AB01     		.2byte	0x1ab
 1262 03fd BC000000 		.4byte	0xbc
 1263 0401 02       		.byte	0x2
 1264 0402 23       		.byte	0x23
 1265 0403 18       		.uleb128 0x18
 1266 0404 08       		.uleb128 0x8
 1267 0405 38010000 		.4byte	.LASF46
 1268 0409 07       		.byte	0x7
 1269 040a AC01     		.2byte	0x1ac
 1270 040c BC000000 		.4byte	0xbc
 1271 0410 02       		.byte	0x2
 1272 0411 23       		.byte	0x23
 1273 0412 1C       		.uleb128 0x1c
 1274 0413 08       		.uleb128 0x8
 1275 0414 52000000 		.4byte	.LASF47
 1276 0418 07       		.byte	0x7
 1277 0419 AD01     		.2byte	0x1ad
 1278 041b BC000000 		.4byte	0xbc
 1279 041f 02       		.byte	0x2
 1280 0420 23       		.byte	0x23
 1281 0421 20       		.uleb128 0x20
 1282 0422 09       		.uleb128 0x9
 1283 0423 43535200 		.ascii	"CSR\000"
 1284 0427 07       		.byte	0x7
 1285 0428 AE01     		.2byte	0x1ae
 1286 042a BC000000 		.4byte	0xbc
 1287 042e 02       		.byte	0x2
 1288 042f 23       		.byte	0x23
 1289 0430 24       		.uleb128 0x24
 1290 0431 00       		.byte	0
 1291 0432 0C       		.uleb128 0xc
 1292 0433 10020000 		.4byte	.LASF48
 1293 0437 07       		.byte	0x7
 1294 0438 B101     		.2byte	0x1b1
 1295 043a 93030000 		.4byte	0x393
 1296 043e 0F       		.uleb128 0xf
 1297 043f 01       		.byte	0x1
 1298 0440 37000000 		.4byte	0x37
 1299 0444 08       		.byte	0x8
 1300 0445 98       		.byte	0x98
 1301 0446 57040000 		.4byte	0x457
 1302 044a 10       		.uleb128 0x10
 1303 044b 7C040000 		.4byte	.LASF49
 1304 044f 00       		.byte	0
 1305 0450 11       		.uleb128 0x11
 1306 0451 53455400 		.ascii	"SET\000"
ARM GAS  /tmp/cciAnlD7.s 			page 52


 1307 0455 01       		.byte	0x1
 1308 0456 00       		.byte	0
 1309 0457 0F       		.uleb128 0xf
 1310 0458 01       		.byte	0x1
 1311 0459 37000000 		.4byte	0x37
 1312 045d 08       		.byte	0x8
 1313 045e 9E       		.byte	0x9e
 1314 045f 70040000 		.4byte	0x470
 1315 0463 10       		.uleb128 0x10
 1316 0464 60010000 		.4byte	.LASF50
 1317 0468 00       		.byte	0
 1318 0469 10       		.uleb128 0x10
 1319 046a E2040000 		.4byte	.LASF51
 1320 046e 01       		.byte	0x1
 1321 046f 00       		.byte	0
 1322 0470 02       		.uleb128 0x2
 1323 0471 08       		.byte	0x8
 1324 0472 04       		.byte	0x4
 1325 0473 7C020000 		.4byte	.LASF52
 1326 0477 12       		.uleb128 0x12
 1327 0478 08       		.byte	0x8
 1328 0479 09       		.byte	0x9
 1329 047a 30       		.byte	0x30
 1330 047b 9C040000 		.4byte	0x49c
 1331 047f 13       		.uleb128 0x13
 1332 0480 B2040000 		.4byte	.LASF53
 1333 0484 09       		.byte	0x9
 1334 0485 32       		.byte	0x32
 1335 0486 B1000000 		.4byte	0xb1
 1336 048a 02       		.byte	0x2
 1337 048b 23       		.byte	0x23
 1338 048c 00       		.uleb128 0
 1339 048d 13       		.uleb128 0x13
 1340 048e 6D040000 		.4byte	.LASF54
 1341 0492 09       		.byte	0x9
 1342 0493 35       		.byte	0x35
 1343 0494 B1000000 		.4byte	0xb1
 1344 0498 02       		.byte	0x2
 1345 0499 23       		.byte	0x23
 1346 049a 04       		.uleb128 0x4
 1347 049b 00       		.byte	0
 1348 049c 03       		.uleb128 0x3
 1349 049d 2F000000 		.4byte	.LASF55
 1350 04a1 09       		.byte	0x9
 1351 04a2 37       		.byte	0x37
 1352 04a3 77040000 		.4byte	0x477
 1353 04a7 0F       		.uleb128 0xf
 1354 04a8 01       		.byte	0x1
 1355 04a9 37000000 		.4byte	0x37
 1356 04ad 0A       		.byte	0xa
 1357 04ae 33       		.byte	0x33
 1358 04af CC040000 		.4byte	0x4cc
 1359 04b3 10       		.uleb128 0x10
 1360 04b4 0D040000 		.4byte	.LASF56
 1361 04b8 64       		.byte	0x64
 1362 04b9 10       		.uleb128 0x10
 1363 04ba F9030000 		.4byte	.LASF57
ARM GAS  /tmp/cciAnlD7.s 			page 53


 1364 04be 0A       		.byte	0xa
 1365 04bf 10       		.uleb128 0x10
 1366 04c0 5B030000 		.4byte	.LASF58
 1367 04c4 01       		.byte	0x1
 1368 04c5 10       		.uleb128 0x10
 1369 04c6 CC040000 		.4byte	.LASF59
 1370 04ca 01       		.byte	0x1
 1371 04cb 00       		.byte	0
 1372 04cc 03       		.uleb128 0x3
 1373 04cd B5010000 		.4byte	.LASF60
 1374 04d1 0A       		.byte	0xa
 1375 04d2 38       		.byte	0x38
 1376 04d3 A7040000 		.4byte	0x4a7
 1377 04d7 0E       		.uleb128 0xe
 1378 04d8 46030000 		.4byte	.LASF61
 1379 04dc 0A       		.byte	0xa
 1380 04dd 3D       		.byte	0x3d
 1381 04de B1000000 		.4byte	0xb1
 1382 04e2 01       		.byte	0x1
 1383 04e3 01       		.byte	0x1
 1384 04e4 0E       		.uleb128 0xe
 1385 04e5 2E030000 		.4byte	.LASF62
 1386 04e9 0A       		.byte	0xa
 1387 04ea 3E       		.byte	0x3e
 1388 04eb CC040000 		.4byte	0x4cc
 1389 04ef 01       		.byte	0x1
 1390 04f0 01       		.byte	0x1
 1391 04f1 14       		.uleb128 0x14
 1392 04f2 01       		.byte	0x1
 1393 04f3 96010000 		.4byte	.LASF63
 1394 04f7 01       		.byte	0x1
 1395 04f8 5502     		.2byte	0x255
 1396 04fa 01       		.byte	0x1
 1397 04fb B4010000 		.4byte	.LFB82
 1398 04ff B6010000 		.4byte	.LFE82
 1399 0503 02       		.byte	0x2
 1400 0504 7D       		.byte	0x7d
 1401 0505 00       		.sleb128 0
 1402 0506 01       		.byte	0x1
 1403 0507 15       		.uleb128 0x15
 1404 0508 01       		.byte	0x1
 1405 0509 81030000 		.4byte	.LASF69
 1406 050d 01       		.byte	0x1
 1407 050e 4402     		.2byte	0x244
 1408 0510 01       		.byte	0x1
 1409 0511 B6010000 		.4byte	.LFB81
 1410 0515 D0010000 		.4byte	.LFE81
 1411 0519 00000000 		.4byte	.LLST7
 1412 051d 01       		.byte	0x1
 1413 051e 2C050000 		.4byte	0x52c
 1414 0522 16       		.uleb128 0x16
 1415 0523 C4010000 		.4byte	.LVL11
 1416 0527 F1040000 		.4byte	0x4f1
 1417 052b 00       		.byte	0
 1418 052c 14       		.uleb128 0x14
 1419 052d 01       		.byte	0x1
 1420 052e 71000000 		.4byte	.LASF64
ARM GAS  /tmp/cciAnlD7.s 			page 54


 1421 0532 01       		.byte	0x1
 1422 0533 3702     		.2byte	0x237
 1423 0535 01       		.byte	0x1
 1424 0536 A4010000 		.4byte	.LFB80
 1425 053a B4010000 		.4byte	.LFE80
 1426 053e 02       		.byte	0x2
 1427 053f 7D       		.byte	0x7d
 1428 0540 00       		.sleb128 0
 1429 0541 01       		.byte	0x1
 1430 0542 14       		.uleb128 0x14
 1431 0543 01       		.byte	0x1
 1432 0544 11000000 		.4byte	.LASF65
 1433 0548 01       		.byte	0x1
 1434 0549 2A02     		.2byte	0x22a
 1435 054b 01       		.byte	0x1
 1436 054c 94010000 		.4byte	.LFB79
 1437 0550 A4010000 		.4byte	.LFE79
 1438 0554 02       		.byte	0x2
 1439 0555 7D       		.byte	0x7d
 1440 0556 00       		.sleb128 0
 1441 0557 01       		.byte	0x1
 1442 0558 14       		.uleb128 0x14
 1443 0559 01       		.byte	0x1
 1444 055a C9030000 		.4byte	.LASF66
 1445 055e 01       		.byte	0x1
 1446 055f 1D02     		.2byte	0x21d
 1447 0561 01       		.byte	0x1
 1448 0562 84010000 		.4byte	.LFB78
 1449 0566 94010000 		.4byte	.LFE78
 1450 056a 02       		.byte	0x2
 1451 056b 7D       		.byte	0x7d
 1452 056c 00       		.sleb128 0
 1453 056d 01       		.byte	0x1
 1454 056e 14       		.uleb128 0x14
 1455 056f 01       		.byte	0x1
 1456 0570 F6010000 		.4byte	.LASF67
 1457 0574 01       		.byte	0x1
 1458 0575 1002     		.2byte	0x210
 1459 0577 01       		.byte	0x1
 1460 0578 74010000 		.4byte	.LFB77
 1461 057c 84010000 		.4byte	.LFE77
 1462 0580 02       		.byte	0x2
 1463 0581 7D       		.byte	0x7d
 1464 0582 00       		.sleb128 0
 1465 0583 01       		.byte	0x1
 1466 0584 14       		.uleb128 0x14
 1467 0585 01       		.byte	0x1
 1468 0586 1C020000 		.4byte	.LASF68
 1469 058a 01       		.byte	0x1
 1470 058b F701     		.2byte	0x1f7
 1471 058d 01       		.byte	0x1
 1472 058e 54010000 		.4byte	.LFB76
 1473 0592 74010000 		.4byte	.LFE76
 1474 0596 02       		.byte	0x2
 1475 0597 7D       		.byte	0x7d
 1476 0598 00       		.sleb128 0
 1477 0599 01       		.byte	0x1
ARM GAS  /tmp/cciAnlD7.s 			page 55


 1478 059a 15       		.uleb128 0x15
 1479 059b 01       		.byte	0x1
 1480 059c F4000000 		.4byte	.LASF70
 1481 05a0 01       		.byte	0x1
 1482 05a1 CF01     		.2byte	0x1cf
 1483 05a3 01       		.byte	0x1
 1484 05a4 0C010000 		.4byte	.LFB75
 1485 05a8 54010000 		.4byte	.LFE75
 1486 05ac 20000000 		.4byte	.LLST5
 1487 05b0 01       		.byte	0x1
 1488 05b1 E6050000 		.4byte	0x5e6
 1489 05b5 17       		.uleb128 0x17
 1490 05b6 07000000 		.4byte	.LASF71
 1491 05ba 01       		.byte	0x1
 1492 05bb CF01     		.2byte	0x1cf
 1493 05bd B1000000 		.4byte	0xb1
 1494 05c1 40000000 		.4byte	.LLST6
 1495 05c5 18       		.uleb128 0x18
 1496 05c6 88020000 		.4byte	.LASF72
 1497 05ca 01       		.byte	0x1
 1498 05cb CF01     		.2byte	0x1cf
 1499 05cd 8C000000 		.4byte	0x8c
 1500 05d1 01       		.byte	0x1
 1501 05d2 51       		.byte	0x51
 1502 05d3 16       		.uleb128 0x16
 1503 05d4 44010000 		.4byte	.LVL9
 1504 05d8 61070000 		.4byte	0x761
 1505 05dc 16       		.uleb128 0x16
 1506 05dd 48010000 		.4byte	.LVL10
 1507 05e1 61070000 		.4byte	0x761
 1508 05e5 00       		.byte	0
 1509 05e6 19       		.uleb128 0x19
 1510 05e7 01       		.byte	0x1
 1511 05e8 C9010000 		.4byte	.LASF73
 1512 05ec 01       		.byte	0x1
 1513 05ed A101     		.2byte	0x1a1
 1514 05ef 01       		.byte	0x1
 1515 05f0 EC000000 		.4byte	.LFB74
 1516 05f4 0C010000 		.4byte	.LFE74
 1517 05f8 02       		.byte	0x2
 1518 05f9 7D       		.byte	0x7d
 1519 05fa 00       		.sleb128 0
 1520 05fb 01       		.byte	0x1
 1521 05fc 1D060000 		.4byte	0x61d
 1522 0600 18       		.uleb128 0x18
 1523 0601 07000000 		.4byte	.LASF71
 1524 0605 01       		.byte	0x1
 1525 0606 A101     		.2byte	0x1a1
 1526 0608 B1000000 		.4byte	0xb1
 1527 060c 01       		.byte	0x1
 1528 060d 50       		.byte	0x50
 1529 060e 18       		.uleb128 0x18
 1530 060f 3E000000 		.4byte	.LASF74
 1531 0613 01       		.byte	0x1
 1532 0614 A101     		.2byte	0x1a1
 1533 0616 8C000000 		.4byte	0x8c
 1534 061a 01       		.byte	0x1
ARM GAS  /tmp/cciAnlD7.s 			page 56


 1535 061b 51       		.byte	0x51
 1536 061c 00       		.byte	0
 1537 061d 19       		.uleb128 0x19
 1538 061e 01       		.byte	0x1
 1539 061f EC020000 		.4byte	.LASF75
 1540 0623 01       		.byte	0x1
 1541 0624 8D01     		.2byte	0x18d
 1542 0626 01       		.byte	0x1
 1543 0627 D4000000 		.4byte	.LFB73
 1544 062b EC000000 		.4byte	.LFE73
 1545 062f 02       		.byte	0x2
 1546 0630 7D       		.byte	0x7d
 1547 0631 00       		.sleb128 0
 1548 0632 01       		.byte	0x1
 1549 0633 71060000 		.4byte	0x671
 1550 0637 17       		.uleb128 0x17
 1551 0638 AA010000 		.4byte	.LASF76
 1552 063c 01       		.byte	0x1
 1553 063d 8D01     		.2byte	0x18d
 1554 063f B1000000 		.4byte	0xb1
 1555 0643 61000000 		.4byte	.LLST3
 1556 0647 1A       		.uleb128 0x1a
 1557 0648 75070000 		.4byte	0x775
 1558 064c D4000000 		.4byte	.LBB8
 1559 0650 D8000000 		.4byte	.LBE8
 1560 0654 01       		.byte	0x1
 1561 0655 9201     		.2byte	0x192
 1562 0657 1B       		.uleb128 0x1b
 1563 0658 83070000 		.4byte	0x783
 1564 065c 82000000 		.4byte	.LLST4
 1565 0660 1C       		.uleb128 0x1c
 1566 0661 D4000000 		.4byte	.LBB9
 1567 0665 D8000000 		.4byte	.LBE9
 1568 0669 1D       		.uleb128 0x1d
 1569 066a 8F070000 		.4byte	0x78f
 1570 066e 00       		.byte	0
 1571 066f 00       		.byte	0
 1572 0670 00       		.byte	0
 1573 0671 19       		.uleb128 0x19
 1574 0672 01       		.byte	0x1
 1575 0673 25040000 		.4byte	.LASF77
 1576 0677 01       		.byte	0x1
 1577 0678 7E01     		.2byte	0x17e
 1578 067a 01       		.byte	0x1
 1579 067b BC000000 		.4byte	.LFB72
 1580 067f D4000000 		.4byte	.LFE72
 1581 0683 02       		.byte	0x2
 1582 0684 7D       		.byte	0x7d
 1583 0685 00       		.sleb128 0
 1584 0686 01       		.byte	0x1
 1585 0687 C5060000 		.4byte	0x6c5
 1586 068b 17       		.uleb128 0x17
 1587 068c AA010000 		.4byte	.LASF76
 1588 0690 01       		.byte	0x1
 1589 0691 7E01     		.2byte	0x17e
 1590 0693 B1000000 		.4byte	0xb1
 1591 0697 95000000 		.4byte	.LLST1
ARM GAS  /tmp/cciAnlD7.s 			page 57


 1592 069b 1A       		.uleb128 0x1a
 1593 069c 75070000 		.4byte	0x775
 1594 06a0 BC000000 		.4byte	.LBB6
 1595 06a4 C0000000 		.4byte	.LBE6
 1596 06a8 01       		.byte	0x1
 1597 06a9 8301     		.2byte	0x183
 1598 06ab 1B       		.uleb128 0x1b
 1599 06ac 83070000 		.4byte	0x783
 1600 06b0 B6000000 		.4byte	.LLST2
 1601 06b4 1C       		.uleb128 0x1c
 1602 06b5 BC000000 		.4byte	.LBB7
 1603 06b9 C0000000 		.4byte	.LBE7
 1604 06bd 1D       		.uleb128 0x1d
 1605 06be 8F070000 		.4byte	0x78f
 1606 06c2 00       		.byte	0
 1607 06c3 00       		.byte	0
 1608 06c4 00       		.byte	0
 1609 06c5 14       		.uleb128 0x14
 1610 06c6 01       		.byte	0x1
 1611 06c7 4F020000 		.4byte	.LASF78
 1612 06cb 01       		.byte	0x1
 1613 06cc 7101     		.2byte	0x171
 1614 06ce 01       		.byte	0x1
 1615 06cf B0000000 		.4byte	.LFB71
 1616 06d3 BC000000 		.4byte	.LFE71
 1617 06d7 02       		.byte	0x2
 1618 06d8 7D       		.byte	0x7d
 1619 06d9 00       		.sleb128 0
 1620 06da 01       		.byte	0x1
 1621 06db 14       		.uleb128 0x14
 1622 06dc 01       		.byte	0x1
 1623 06dd DA020000 		.4byte	.LASF79
 1624 06e1 01       		.byte	0x1
 1625 06e2 6701     		.2byte	0x167
 1626 06e4 01       		.byte	0x1
 1627 06e5 A4000000 		.4byte	.LFB70
 1628 06e9 B0000000 		.4byte	.LFE70
 1629 06ed 02       		.byte	0x2
 1630 06ee 7D       		.byte	0x7d
 1631 06ef 00       		.sleb128 0
 1632 06f0 01       		.byte	0x1
 1633 06f1 19       		.uleb128 0x19
 1634 06f2 01       		.byte	0x1
 1635 06f3 4E010000 		.4byte	.LASF80
 1636 06f7 01       		.byte	0x1
 1637 06f8 3C01     		.2byte	0x13c
 1638 06fa 01       		.byte	0x1
 1639 06fb 38000000 		.4byte	.LFB69
 1640 06ff A4000000 		.4byte	.LFE69
 1641 0703 02       		.byte	0x2
 1642 0704 7D       		.byte	0x7d
 1643 0705 00       		.sleb128 0
 1644 0706 01       		.byte	0x1
 1645 0707 1C070000 		.4byte	0x71c
 1646 070b 17       		.uleb128 0x17
 1647 070c BB040000 		.4byte	.LASF81
 1648 0710 01       		.byte	0x1
ARM GAS  /tmp/cciAnlD7.s 			page 58


 1649 0711 3C01     		.2byte	0x13c
 1650 0713 1C070000 		.4byte	0x71c
 1651 0717 C9000000 		.4byte	.LLST0
 1652 071b 00       		.byte	0
 1653 071c 1E       		.uleb128 0x1e
 1654 071d 04       		.byte	0x4
 1655 071e 9C040000 		.4byte	0x49c
 1656 0722 1F       		.uleb128 0x1f
 1657 0723 01       		.byte	0x1
 1658 0724 AA030000 		.4byte	.LASF82
 1659 0728 01       		.byte	0x1
 1660 0729 B6       		.byte	0xb6
 1661 072a 01       		.byte	0x1
 1662 072b 2C000000 		.4byte	.LFB68
 1663 072f 38000000 		.4byte	.LFE68
 1664 0733 02       		.byte	0x2
 1665 0734 7D       		.byte	0x7d
 1666 0735 00       		.sleb128 0
 1667 0736 01       		.byte	0x1
 1668 0737 1F       		.uleb128 0x1f
 1669 0738 01       		.byte	0x1
 1670 0739 87040000 		.4byte	.LASF83
 1671 073d 01       		.byte	0x1
 1672 073e A9       		.byte	0xa9
 1673 073f 01       		.byte	0x1
 1674 0740 20000000 		.4byte	.LFB67
 1675 0744 2C000000 		.4byte	.LFE67
 1676 0748 02       		.byte	0x2
 1677 0749 7D       		.byte	0x7d
 1678 074a 00       		.sleb128 0
 1679 074b 01       		.byte	0x1
 1680 074c 1F       		.uleb128 0x1f
 1681 074d 01       		.byte	0x1
 1682 074e 87010000 		.4byte	.LASF84
 1683 0752 01       		.byte	0x1
 1684 0753 9C       		.byte	0x9c
 1685 0754 01       		.byte	0x1
 1686 0755 06000000 		.4byte	.LFB66
 1687 0759 20000000 		.4byte	.LFE66
 1688 075d 02       		.byte	0x2
 1689 075e 7D       		.byte	0x7d
 1690 075f 00       		.sleb128 0
 1691 0760 01       		.byte	0x1
 1692 0761 20       		.uleb128 0x20
 1693 0762 77010000 		.4byte	.LASF88
 1694 0766 01       		.byte	0x1
 1695 0767 75       		.byte	0x75
 1696 0768 01       		.byte	0x1
 1697 0769 00000000 		.4byte	.LFB65
 1698 076d 06000000 		.4byte	.LFE65
 1699 0771 02       		.byte	0x2
 1700 0772 7D       		.byte	0x7d
 1701 0773 00       		.sleb128 0
 1702 0774 01       		.byte	0x1
 1703 0775 21       		.uleb128 0x21
 1704 0776 67020000 		.4byte	.LASF89
 1705 077a 02       		.byte	0x2
ARM GAS  /tmp/cciAnlD7.s 			page 59


 1706 077b D503     		.2byte	0x3d5
 1707 077d 01       		.byte	0x1
 1708 077e B1000000 		.4byte	0xb1
 1709 0782 03       		.byte	0x3
 1710 0783 22       		.uleb128 0x22
 1711 0784 EE000000 		.4byte	.LASF90
 1712 0788 02       		.byte	0x2
 1713 0789 D503     		.2byte	0x3d5
 1714 078b B1000000 		.4byte	0xb1
 1715 078f 23       		.uleb128 0x23
 1716 0790 00000000 		.4byte	.LASF91
 1717 0794 02       		.byte	0x2
 1718 0795 D703     		.2byte	0x3d7
 1719 0797 B1000000 		.4byte	0xb1
 1720 079b 00       		.byte	0
 1721 079c 00       		.byte	0
 1722              		.section	.debug_abbrev,"",%progbits
 1723              	.Ldebug_abbrev0:
 1724 0000 01       		.uleb128 0x1
 1725 0001 11       		.uleb128 0x11
 1726 0002 01       		.byte	0x1
 1727 0003 25       		.uleb128 0x25
 1728 0004 0E       		.uleb128 0xe
 1729 0005 13       		.uleb128 0x13
 1730 0006 0B       		.uleb128 0xb
 1731 0007 03       		.uleb128 0x3
 1732 0008 0E       		.uleb128 0xe
 1733 0009 1B       		.uleb128 0x1b
 1734 000a 0E       		.uleb128 0xe
 1735 000b 11       		.uleb128 0x11
 1736 000c 01       		.uleb128 0x1
 1737 000d 12       		.uleb128 0x12
 1738 000e 01       		.uleb128 0x1
 1739 000f 10       		.uleb128 0x10
 1740 0010 06       		.uleb128 0x6
 1741 0011 00       		.byte	0
 1742 0012 00       		.byte	0
 1743 0013 02       		.uleb128 0x2
 1744 0014 24       		.uleb128 0x24
 1745 0015 00       		.byte	0
 1746 0016 0B       		.uleb128 0xb
 1747 0017 0B       		.uleb128 0xb
 1748 0018 3E       		.uleb128 0x3e
 1749 0019 0B       		.uleb128 0xb
 1750 001a 03       		.uleb128 0x3
 1751 001b 0E       		.uleb128 0xe
 1752 001c 00       		.byte	0
 1753 001d 00       		.byte	0
 1754 001e 03       		.uleb128 0x3
 1755 001f 16       		.uleb128 0x16
 1756 0020 00       		.byte	0
 1757 0021 03       		.uleb128 0x3
 1758 0022 0E       		.uleb128 0xe
 1759 0023 3A       		.uleb128 0x3a
 1760 0024 0B       		.uleb128 0xb
 1761 0025 3B       		.uleb128 0x3b
 1762 0026 0B       		.uleb128 0xb
ARM GAS  /tmp/cciAnlD7.s 			page 60


 1763 0027 49       		.uleb128 0x49
 1764 0028 13       		.uleb128 0x13
 1765 0029 00       		.byte	0
 1766 002a 00       		.byte	0
 1767 002b 04       		.uleb128 0x4
 1768 002c 24       		.uleb128 0x24
 1769 002d 00       		.byte	0
 1770 002e 0B       		.uleb128 0xb
 1771 002f 0B       		.uleb128 0xb
 1772 0030 3E       		.uleb128 0x3e
 1773 0031 0B       		.uleb128 0xb
 1774 0032 03       		.uleb128 0x3
 1775 0033 08       		.uleb128 0x8
 1776 0034 00       		.byte	0
 1777 0035 00       		.byte	0
 1778 0036 05       		.uleb128 0x5
 1779 0037 35       		.uleb128 0x35
 1780 0038 00       		.byte	0
 1781 0039 49       		.uleb128 0x49
 1782 003a 13       		.uleb128 0x13
 1783 003b 00       		.byte	0
 1784 003c 00       		.byte	0
 1785 003d 06       		.uleb128 0x6
 1786 003e 26       		.uleb128 0x26
 1787 003f 00       		.byte	0
 1788 0040 49       		.uleb128 0x49
 1789 0041 13       		.uleb128 0x13
 1790 0042 00       		.byte	0
 1791 0043 00       		.byte	0
 1792 0044 07       		.uleb128 0x7
 1793 0045 13       		.uleb128 0x13
 1794 0046 01       		.byte	0x1
 1795 0047 0B       		.uleb128 0xb
 1796 0048 0B       		.uleb128 0xb
 1797 0049 3A       		.uleb128 0x3a
 1798 004a 0B       		.uleb128 0xb
 1799 004b 3B       		.uleb128 0x3b
 1800 004c 05       		.uleb128 0x5
 1801 004d 01       		.uleb128 0x1
 1802 004e 13       		.uleb128 0x13
 1803 004f 00       		.byte	0
 1804 0050 00       		.byte	0
 1805 0051 08       		.uleb128 0x8
 1806 0052 0D       		.uleb128 0xd
 1807 0053 00       		.byte	0
 1808 0054 03       		.uleb128 0x3
 1809 0055 0E       		.uleb128 0xe
 1810 0056 3A       		.uleb128 0x3a
 1811 0057 0B       		.uleb128 0xb
 1812 0058 3B       		.uleb128 0x3b
 1813 0059 05       		.uleb128 0x5
 1814 005a 49       		.uleb128 0x49
 1815 005b 13       		.uleb128 0x13
 1816 005c 38       		.uleb128 0x38
 1817 005d 0A       		.uleb128 0xa
 1818 005e 00       		.byte	0
 1819 005f 00       		.byte	0
ARM GAS  /tmp/cciAnlD7.s 			page 61


 1820 0060 09       		.uleb128 0x9
 1821 0061 0D       		.uleb128 0xd
 1822 0062 00       		.byte	0
 1823 0063 03       		.uleb128 0x3
 1824 0064 08       		.uleb128 0x8
 1825 0065 3A       		.uleb128 0x3a
 1826 0066 0B       		.uleb128 0xb
 1827 0067 3B       		.uleb128 0x3b
 1828 0068 05       		.uleb128 0x5
 1829 0069 49       		.uleb128 0x49
 1830 006a 13       		.uleb128 0x13
 1831 006b 38       		.uleb128 0x38
 1832 006c 0A       		.uleb128 0xa
 1833 006d 00       		.byte	0
 1834 006e 00       		.byte	0
 1835 006f 0A       		.uleb128 0xa
 1836 0070 01       		.uleb128 0x1
 1837 0071 01       		.byte	0x1
 1838 0072 49       		.uleb128 0x49
 1839 0073 13       		.uleb128 0x13
 1840 0074 01       		.uleb128 0x1
 1841 0075 13       		.uleb128 0x13
 1842 0076 00       		.byte	0
 1843 0077 00       		.byte	0
 1844 0078 0B       		.uleb128 0xb
 1845 0079 21       		.uleb128 0x21
 1846 007a 00       		.byte	0
 1847 007b 49       		.uleb128 0x49
 1848 007c 13       		.uleb128 0x13
 1849 007d 2F       		.uleb128 0x2f
 1850 007e 0B       		.uleb128 0xb
 1851 007f 00       		.byte	0
 1852 0080 00       		.byte	0
 1853 0081 0C       		.uleb128 0xc
 1854 0082 16       		.uleb128 0x16
 1855 0083 00       		.byte	0
 1856 0084 03       		.uleb128 0x3
 1857 0085 0E       		.uleb128 0xe
 1858 0086 3A       		.uleb128 0x3a
 1859 0087 0B       		.uleb128 0xb
 1860 0088 3B       		.uleb128 0x3b
 1861 0089 05       		.uleb128 0x5
 1862 008a 49       		.uleb128 0x49
 1863 008b 13       		.uleb128 0x13
 1864 008c 00       		.byte	0
 1865 008d 00       		.byte	0
 1866 008e 0D       		.uleb128 0xd
 1867 008f 34       		.uleb128 0x34
 1868 0090 00       		.byte	0
 1869 0091 03       		.uleb128 0x3
 1870 0092 0E       		.uleb128 0xe
 1871 0093 3A       		.uleb128 0x3a
 1872 0094 0B       		.uleb128 0xb
 1873 0095 3B       		.uleb128 0x3b
 1874 0096 05       		.uleb128 0x5
 1875 0097 49       		.uleb128 0x49
 1876 0098 13       		.uleb128 0x13
ARM GAS  /tmp/cciAnlD7.s 			page 62


 1877 0099 3F       		.uleb128 0x3f
 1878 009a 0C       		.uleb128 0xc
 1879 009b 3C       		.uleb128 0x3c
 1880 009c 0C       		.uleb128 0xc
 1881 009d 00       		.byte	0
 1882 009e 00       		.byte	0
 1883 009f 0E       		.uleb128 0xe
 1884 00a0 34       		.uleb128 0x34
 1885 00a1 00       		.byte	0
 1886 00a2 03       		.uleb128 0x3
 1887 00a3 0E       		.uleb128 0xe
 1888 00a4 3A       		.uleb128 0x3a
 1889 00a5 0B       		.uleb128 0xb
 1890 00a6 3B       		.uleb128 0x3b
 1891 00a7 0B       		.uleb128 0xb
 1892 00a8 49       		.uleb128 0x49
 1893 00a9 13       		.uleb128 0x13
 1894 00aa 3F       		.uleb128 0x3f
 1895 00ab 0C       		.uleb128 0xc
 1896 00ac 3C       		.uleb128 0x3c
 1897 00ad 0C       		.uleb128 0xc
 1898 00ae 00       		.byte	0
 1899 00af 00       		.byte	0
 1900 00b0 0F       		.uleb128 0xf
 1901 00b1 04       		.uleb128 0x4
 1902 00b2 01       		.byte	0x1
 1903 00b3 0B       		.uleb128 0xb
 1904 00b4 0B       		.uleb128 0xb
 1905 00b5 49       		.uleb128 0x49
 1906 00b6 13       		.uleb128 0x13
 1907 00b7 3A       		.uleb128 0x3a
 1908 00b8 0B       		.uleb128 0xb
 1909 00b9 3B       		.uleb128 0x3b
 1910 00ba 0B       		.uleb128 0xb
 1911 00bb 01       		.uleb128 0x1
 1912 00bc 13       		.uleb128 0x13
 1913 00bd 00       		.byte	0
 1914 00be 00       		.byte	0
 1915 00bf 10       		.uleb128 0x10
 1916 00c0 28       		.uleb128 0x28
 1917 00c1 00       		.byte	0
 1918 00c2 03       		.uleb128 0x3
 1919 00c3 0E       		.uleb128 0xe
 1920 00c4 1C       		.uleb128 0x1c
 1921 00c5 0B       		.uleb128 0xb
 1922 00c6 00       		.byte	0
 1923 00c7 00       		.byte	0
 1924 00c8 11       		.uleb128 0x11
 1925 00c9 28       		.uleb128 0x28
 1926 00ca 00       		.byte	0
 1927 00cb 03       		.uleb128 0x3
 1928 00cc 08       		.uleb128 0x8
 1929 00cd 1C       		.uleb128 0x1c
 1930 00ce 0B       		.uleb128 0xb
 1931 00cf 00       		.byte	0
 1932 00d0 00       		.byte	0
 1933 00d1 12       		.uleb128 0x12
ARM GAS  /tmp/cciAnlD7.s 			page 63


 1934 00d2 13       		.uleb128 0x13
 1935 00d3 01       		.byte	0x1
 1936 00d4 0B       		.uleb128 0xb
 1937 00d5 0B       		.uleb128 0xb
 1938 00d6 3A       		.uleb128 0x3a
 1939 00d7 0B       		.uleb128 0xb
 1940 00d8 3B       		.uleb128 0x3b
 1941 00d9 0B       		.uleb128 0xb
 1942 00da 01       		.uleb128 0x1
 1943 00db 13       		.uleb128 0x13
 1944 00dc 00       		.byte	0
 1945 00dd 00       		.byte	0
 1946 00de 13       		.uleb128 0x13
 1947 00df 0D       		.uleb128 0xd
 1948 00e0 00       		.byte	0
 1949 00e1 03       		.uleb128 0x3
 1950 00e2 0E       		.uleb128 0xe
 1951 00e3 3A       		.uleb128 0x3a
 1952 00e4 0B       		.uleb128 0xb
 1953 00e5 3B       		.uleb128 0x3b
 1954 00e6 0B       		.uleb128 0xb
 1955 00e7 49       		.uleb128 0x49
 1956 00e8 13       		.uleb128 0x13
 1957 00e9 38       		.uleb128 0x38
 1958 00ea 0A       		.uleb128 0xa
 1959 00eb 00       		.byte	0
 1960 00ec 00       		.byte	0
 1961 00ed 14       		.uleb128 0x14
 1962 00ee 2E       		.uleb128 0x2e
 1963 00ef 00       		.byte	0
 1964 00f0 3F       		.uleb128 0x3f
 1965 00f1 0C       		.uleb128 0xc
 1966 00f2 03       		.uleb128 0x3
 1967 00f3 0E       		.uleb128 0xe
 1968 00f4 3A       		.uleb128 0x3a
 1969 00f5 0B       		.uleb128 0xb
 1970 00f6 3B       		.uleb128 0x3b
 1971 00f7 05       		.uleb128 0x5
 1972 00f8 27       		.uleb128 0x27
 1973 00f9 0C       		.uleb128 0xc
 1974 00fa 11       		.uleb128 0x11
 1975 00fb 01       		.uleb128 0x1
 1976 00fc 12       		.uleb128 0x12
 1977 00fd 01       		.uleb128 0x1
 1978 00fe 40       		.uleb128 0x40
 1979 00ff 0A       		.uleb128 0xa
 1980 0100 9742     		.uleb128 0x2117
 1981 0102 0C       		.uleb128 0xc
 1982 0103 00       		.byte	0
 1983 0104 00       		.byte	0
 1984 0105 15       		.uleb128 0x15
 1985 0106 2E       		.uleb128 0x2e
 1986 0107 01       		.byte	0x1
 1987 0108 3F       		.uleb128 0x3f
 1988 0109 0C       		.uleb128 0xc
 1989 010a 03       		.uleb128 0x3
 1990 010b 0E       		.uleb128 0xe
ARM GAS  /tmp/cciAnlD7.s 			page 64


 1991 010c 3A       		.uleb128 0x3a
 1992 010d 0B       		.uleb128 0xb
 1993 010e 3B       		.uleb128 0x3b
 1994 010f 05       		.uleb128 0x5
 1995 0110 27       		.uleb128 0x27
 1996 0111 0C       		.uleb128 0xc
 1997 0112 11       		.uleb128 0x11
 1998 0113 01       		.uleb128 0x1
 1999 0114 12       		.uleb128 0x12
 2000 0115 01       		.uleb128 0x1
 2001 0116 40       		.uleb128 0x40
 2002 0117 06       		.uleb128 0x6
 2003 0118 9742     		.uleb128 0x2117
 2004 011a 0C       		.uleb128 0xc
 2005 011b 01       		.uleb128 0x1
 2006 011c 13       		.uleb128 0x13
 2007 011d 00       		.byte	0
 2008 011e 00       		.byte	0
 2009 011f 16       		.uleb128 0x16
 2010 0120 898201   		.uleb128 0x4109
 2011 0123 00       		.byte	0
 2012 0124 11       		.uleb128 0x11
 2013 0125 01       		.uleb128 0x1
 2014 0126 31       		.uleb128 0x31
 2015 0127 13       		.uleb128 0x13
 2016 0128 00       		.byte	0
 2017 0129 00       		.byte	0
 2018 012a 17       		.uleb128 0x17
 2019 012b 05       		.uleb128 0x5
 2020 012c 00       		.byte	0
 2021 012d 03       		.uleb128 0x3
 2022 012e 0E       		.uleb128 0xe
 2023 012f 3A       		.uleb128 0x3a
 2024 0130 0B       		.uleb128 0xb
 2025 0131 3B       		.uleb128 0x3b
 2026 0132 05       		.uleb128 0x5
 2027 0133 49       		.uleb128 0x49
 2028 0134 13       		.uleb128 0x13
 2029 0135 02       		.uleb128 0x2
 2030 0136 06       		.uleb128 0x6
 2031 0137 00       		.byte	0
 2032 0138 00       		.byte	0
 2033 0139 18       		.uleb128 0x18
 2034 013a 05       		.uleb128 0x5
 2035 013b 00       		.byte	0
 2036 013c 03       		.uleb128 0x3
 2037 013d 0E       		.uleb128 0xe
 2038 013e 3A       		.uleb128 0x3a
 2039 013f 0B       		.uleb128 0xb
 2040 0140 3B       		.uleb128 0x3b
 2041 0141 05       		.uleb128 0x5
 2042 0142 49       		.uleb128 0x49
 2043 0143 13       		.uleb128 0x13
 2044 0144 02       		.uleb128 0x2
 2045 0145 0A       		.uleb128 0xa
 2046 0146 00       		.byte	0
 2047 0147 00       		.byte	0
ARM GAS  /tmp/cciAnlD7.s 			page 65


 2048 0148 19       		.uleb128 0x19
 2049 0149 2E       		.uleb128 0x2e
 2050 014a 01       		.byte	0x1
 2051 014b 3F       		.uleb128 0x3f
 2052 014c 0C       		.uleb128 0xc
 2053 014d 03       		.uleb128 0x3
 2054 014e 0E       		.uleb128 0xe
 2055 014f 3A       		.uleb128 0x3a
 2056 0150 0B       		.uleb128 0xb
 2057 0151 3B       		.uleb128 0x3b
 2058 0152 05       		.uleb128 0x5
 2059 0153 27       		.uleb128 0x27
 2060 0154 0C       		.uleb128 0xc
 2061 0155 11       		.uleb128 0x11
 2062 0156 01       		.uleb128 0x1
 2063 0157 12       		.uleb128 0x12
 2064 0158 01       		.uleb128 0x1
 2065 0159 40       		.uleb128 0x40
 2066 015a 0A       		.uleb128 0xa
 2067 015b 9742     		.uleb128 0x2117
 2068 015d 0C       		.uleb128 0xc
 2069 015e 01       		.uleb128 0x1
 2070 015f 13       		.uleb128 0x13
 2071 0160 00       		.byte	0
 2072 0161 00       		.byte	0
 2073 0162 1A       		.uleb128 0x1a
 2074 0163 1D       		.uleb128 0x1d
 2075 0164 01       		.byte	0x1
 2076 0165 31       		.uleb128 0x31
 2077 0166 13       		.uleb128 0x13
 2078 0167 11       		.uleb128 0x11
 2079 0168 01       		.uleb128 0x1
 2080 0169 12       		.uleb128 0x12
 2081 016a 01       		.uleb128 0x1
 2082 016b 58       		.uleb128 0x58
 2083 016c 0B       		.uleb128 0xb
 2084 016d 59       		.uleb128 0x59
 2085 016e 05       		.uleb128 0x5
 2086 016f 00       		.byte	0
 2087 0170 00       		.byte	0
 2088 0171 1B       		.uleb128 0x1b
 2089 0172 05       		.uleb128 0x5
 2090 0173 00       		.byte	0
 2091 0174 31       		.uleb128 0x31
 2092 0175 13       		.uleb128 0x13
 2093 0176 02       		.uleb128 0x2
 2094 0177 06       		.uleb128 0x6
 2095 0178 00       		.byte	0
 2096 0179 00       		.byte	0
 2097 017a 1C       		.uleb128 0x1c
 2098 017b 0B       		.uleb128 0xb
 2099 017c 01       		.byte	0x1
 2100 017d 11       		.uleb128 0x11
 2101 017e 01       		.uleb128 0x1
 2102 017f 12       		.uleb128 0x12
 2103 0180 01       		.uleb128 0x1
 2104 0181 00       		.byte	0
ARM GAS  /tmp/cciAnlD7.s 			page 66


 2105 0182 00       		.byte	0
 2106 0183 1D       		.uleb128 0x1d
 2107 0184 34       		.uleb128 0x34
 2108 0185 00       		.byte	0
 2109 0186 31       		.uleb128 0x31
 2110 0187 13       		.uleb128 0x13
 2111 0188 00       		.byte	0
 2112 0189 00       		.byte	0
 2113 018a 1E       		.uleb128 0x1e
 2114 018b 0F       		.uleb128 0xf
 2115 018c 00       		.byte	0
 2116 018d 0B       		.uleb128 0xb
 2117 018e 0B       		.uleb128 0xb
 2118 018f 49       		.uleb128 0x49
 2119 0190 13       		.uleb128 0x13
 2120 0191 00       		.byte	0
 2121 0192 00       		.byte	0
 2122 0193 1F       		.uleb128 0x1f
 2123 0194 2E       		.uleb128 0x2e
 2124 0195 00       		.byte	0
 2125 0196 3F       		.uleb128 0x3f
 2126 0197 0C       		.uleb128 0xc
 2127 0198 03       		.uleb128 0x3
 2128 0199 0E       		.uleb128 0xe
 2129 019a 3A       		.uleb128 0x3a
 2130 019b 0B       		.uleb128 0xb
 2131 019c 3B       		.uleb128 0x3b
 2132 019d 0B       		.uleb128 0xb
 2133 019e 27       		.uleb128 0x27
 2134 019f 0C       		.uleb128 0xc
 2135 01a0 11       		.uleb128 0x11
 2136 01a1 01       		.uleb128 0x1
 2137 01a2 12       		.uleb128 0x12
 2138 01a3 01       		.uleb128 0x1
 2139 01a4 40       		.uleb128 0x40
 2140 01a5 0A       		.uleb128 0xa
 2141 01a6 9742     		.uleb128 0x2117
 2142 01a8 0C       		.uleb128 0xc
 2143 01a9 00       		.byte	0
 2144 01aa 00       		.byte	0
 2145 01ab 20       		.uleb128 0x20
 2146 01ac 2E       		.uleb128 0x2e
 2147 01ad 00       		.byte	0
 2148 01ae 03       		.uleb128 0x3
 2149 01af 0E       		.uleb128 0xe
 2150 01b0 3A       		.uleb128 0x3a
 2151 01b1 0B       		.uleb128 0xb
 2152 01b2 3B       		.uleb128 0x3b
 2153 01b3 0B       		.uleb128 0xb
 2154 01b4 27       		.uleb128 0x27
 2155 01b5 0C       		.uleb128 0xc
 2156 01b6 11       		.uleb128 0x11
 2157 01b7 01       		.uleb128 0x1
 2158 01b8 12       		.uleb128 0x12
 2159 01b9 01       		.uleb128 0x1
 2160 01ba 40       		.uleb128 0x40
 2161 01bb 0A       		.uleb128 0xa
ARM GAS  /tmp/cciAnlD7.s 			page 67


 2162 01bc 9742     		.uleb128 0x2117
 2163 01be 0C       		.uleb128 0xc
 2164 01bf 00       		.byte	0
 2165 01c0 00       		.byte	0
 2166 01c1 21       		.uleb128 0x21
 2167 01c2 2E       		.uleb128 0x2e
 2168 01c3 01       		.byte	0x1
 2169 01c4 03       		.uleb128 0x3
 2170 01c5 0E       		.uleb128 0xe
 2171 01c6 3A       		.uleb128 0x3a
 2172 01c7 0B       		.uleb128 0xb
 2173 01c8 3B       		.uleb128 0x3b
 2174 01c9 05       		.uleb128 0x5
 2175 01ca 27       		.uleb128 0x27
 2176 01cb 0C       		.uleb128 0xc
 2177 01cc 49       		.uleb128 0x49
 2178 01cd 13       		.uleb128 0x13
 2179 01ce 20       		.uleb128 0x20
 2180 01cf 0B       		.uleb128 0xb
 2181 01d0 00       		.byte	0
 2182 01d1 00       		.byte	0
 2183 01d2 22       		.uleb128 0x22
 2184 01d3 05       		.uleb128 0x5
 2185 01d4 00       		.byte	0
 2186 01d5 03       		.uleb128 0x3
 2187 01d6 0E       		.uleb128 0xe
 2188 01d7 3A       		.uleb128 0x3a
 2189 01d8 0B       		.uleb128 0xb
 2190 01d9 3B       		.uleb128 0x3b
 2191 01da 05       		.uleb128 0x5
 2192 01db 49       		.uleb128 0x49
 2193 01dc 13       		.uleb128 0x13
 2194 01dd 00       		.byte	0
 2195 01de 00       		.byte	0
 2196 01df 23       		.uleb128 0x23
 2197 01e0 34       		.uleb128 0x34
 2198 01e1 00       		.byte	0
 2199 01e2 03       		.uleb128 0x3
 2200 01e3 0E       		.uleb128 0xe
 2201 01e4 3A       		.uleb128 0x3a
 2202 01e5 0B       		.uleb128 0xb
 2203 01e6 3B       		.uleb128 0x3b
 2204 01e7 05       		.uleb128 0x5
 2205 01e8 49       		.uleb128 0x49
 2206 01e9 13       		.uleb128 0x13
 2207 01ea 00       		.byte	0
 2208 01eb 00       		.byte	0
 2209 01ec 00       		.byte	0
 2210              		.section	.debug_loc,"",%progbits
 2211              	.Ldebug_loc0:
 2212              	.LLST7:
 2213 0000 B6010000 		.4byte	.LFB81-.Ltext0
 2214 0004 B8010000 		.4byte	.LCFI1-.Ltext0
 2215 0008 0200     		.2byte	0x2
 2216 000a 7D       		.byte	0x7d
 2217 000b 00       		.sleb128 0
 2218 000c B8010000 		.4byte	.LCFI1-.Ltext0
ARM GAS  /tmp/cciAnlD7.s 			page 68


 2219 0010 D0010000 		.4byte	.LFE81-.Ltext0
 2220 0014 0200     		.2byte	0x2
 2221 0016 7D       		.byte	0x7d
 2222 0017 08       		.sleb128 8
 2223 0018 00000000 		.4byte	0
 2224 001c 00000000 		.4byte	0
 2225              	.LLST5:
 2226 0020 0C010000 		.4byte	.LFB75-.Ltext0
 2227 0024 10010000 		.4byte	.LCFI0-.Ltext0
 2228 0028 0200     		.2byte	0x2
 2229 002a 7D       		.byte	0x7d
 2230 002b 00       		.sleb128 0
 2231 002c 10010000 		.4byte	.LCFI0-.Ltext0
 2232 0030 54010000 		.4byte	.LFE75-.Ltext0
 2233 0034 0200     		.2byte	0x2
 2234 0036 7D       		.byte	0x7d
 2235 0037 08       		.sleb128 8
 2236 0038 00000000 		.4byte	0
 2237 003c 00000000 		.4byte	0
 2238              	.LLST6:
 2239 0040 0C010000 		.4byte	.LVL7-.Ltext0
 2240 0044 24010000 		.4byte	.LVL8-.Ltext0
 2241 0048 0100     		.2byte	0x1
 2242 004a 50       		.byte	0x50
 2243 004b 24010000 		.4byte	.LVL8-.Ltext0
 2244 004f 54010000 		.4byte	.LFE75-.Ltext0
 2245 0053 0400     		.2byte	0x4
 2246 0055 F3       		.byte	0xf3
 2247 0056 01       		.uleb128 0x1
 2248 0057 50       		.byte	0x50
 2249 0058 9F       		.byte	0x9f
 2250 0059 00000000 		.4byte	0
 2251 005d 00000000 		.4byte	0
 2252              	.LLST3:
 2253 0061 D4000000 		.4byte	.LVL4-.Ltext0
 2254 0065 D8000000 		.4byte	.LVL5-.Ltext0
 2255 0069 0100     		.2byte	0x1
 2256 006b 50       		.byte	0x50
 2257 006c D8000000 		.4byte	.LVL5-.Ltext0
 2258 0070 EC000000 		.4byte	.LFE73-.Ltext0
 2259 0074 0400     		.2byte	0x4
 2260 0076 F3       		.byte	0xf3
 2261 0077 01       		.uleb128 0x1
 2262 0078 50       		.byte	0x50
 2263 0079 9F       		.byte	0x9f
 2264 007a 00000000 		.4byte	0
 2265 007e 00000000 		.4byte	0
 2266              	.LLST4:
 2267 0082 D4000000 		.4byte	.LVL4-.Ltext0
 2268 0086 D8000000 		.4byte	.LVL5-.Ltext0
 2269 008a 0100     		.2byte	0x1
 2270 008c 50       		.byte	0x50
 2271 008d 00000000 		.4byte	0
 2272 0091 00000000 		.4byte	0
 2273              	.LLST1:
 2274 0095 BC000000 		.4byte	.LVL2-.Ltext0
 2275 0099 C0000000 		.4byte	.LVL3-.Ltext0
ARM GAS  /tmp/cciAnlD7.s 			page 69


 2276 009d 0100     		.2byte	0x1
 2277 009f 50       		.byte	0x50
 2278 00a0 C0000000 		.4byte	.LVL3-.Ltext0
 2279 00a4 D4000000 		.4byte	.LFE72-.Ltext0
 2280 00a8 0400     		.2byte	0x4
 2281 00aa F3       		.byte	0xf3
 2282 00ab 01       		.uleb128 0x1
 2283 00ac 50       		.byte	0x50
 2284 00ad 9F       		.byte	0x9f
 2285 00ae 00000000 		.4byte	0
 2286 00b2 00000000 		.4byte	0
 2287              	.LLST2:
 2288 00b6 BC000000 		.4byte	.LVL2-.Ltext0
 2289 00ba C0000000 		.4byte	.LVL3-.Ltext0
 2290 00be 0100     		.2byte	0x1
 2291 00c0 50       		.byte	0x50
 2292 00c1 00000000 		.4byte	0
 2293 00c5 00000000 		.4byte	0
 2294              	.LLST0:
 2295 00c9 38000000 		.4byte	.LVL0-.Ltext0
 2296 00cd 78000000 		.4byte	.LVL1-.Ltext0
 2297 00d1 0100     		.2byte	0x1
 2298 00d3 50       		.byte	0x50
 2299 00d4 78000000 		.4byte	.LVL1-.Ltext0
 2300 00d8 A4000000 		.4byte	.LFE69-.Ltext0
 2301 00dc 0400     		.2byte	0x4
 2302 00de F3       		.byte	0xf3
 2303 00df 01       		.uleb128 0x1
 2304 00e0 50       		.byte	0x50
 2305 00e1 9F       		.byte	0x9f
 2306 00e2 00000000 		.4byte	0
 2307 00e6 00000000 		.4byte	0
 2308              		.section	.debug_aranges,"",%progbits
 2309 0000 1C000000 		.4byte	0x1c
 2310 0004 0200     		.2byte	0x2
 2311 0006 00000000 		.4byte	.Ldebug_info0
 2312 000a 04       		.byte	0x4
 2313 000b 00       		.byte	0
 2314 000c 0000     		.2byte	0
 2315 000e 0000     		.2byte	0
 2316 0010 00000000 		.4byte	.Ltext0
 2317 0014 D0010000 		.4byte	.Letext0-.Ltext0
 2318 0018 00000000 		.4byte	0
 2319 001c 00000000 		.4byte	0
 2320              		.section	.debug_line,"",%progbits
 2321              	.Ldebug_line0:
 2322 0000 CE010000 		.section	.debug_str,"MS",%progbits,1
 2322      02002D01 
 2322      00000201 
 2322      FB0E0D00 
 2322      01010101 
 2323              	.LASF91:
 2324 0000 72657375 		.ascii	"result\000"
 2324      6C7400
 2325              	.LASF71:
 2326 0007 52656775 		.ascii	"Regulator\000"
 2326      6C61746F 
ARM GAS  /tmp/cciAnlD7.s 			page 70


 2326      7200
 2327              	.LASF65:
 2328 0011 48414C5F 		.ascii	"HAL_PWR_EnableSEVOnPend\000"
 2328      5057525F 
 2328      456E6162 
 2328      6C655345 
 2328      564F6E50 
 2329              	.LASF24:
 2330 0029 4D4D4641 		.ascii	"MMFAR\000"
 2330      5200
 2331              	.LASF55:
 2332 002f 5057525F 		.ascii	"PWR_PVDTypeDef\000"
 2332      50564454 
 2332      79706544 
 2332      656600
 2333              	.LASF74:
 2334 003e 534C4545 		.ascii	"SLEEPEntry\000"
 2334      50456E74 
 2334      727900
 2335              	.LASF15:
 2336 0049 73697A65 		.ascii	"sizetype\000"
 2336      74797065 
 2336      00
 2337              	.LASF47:
 2338 0052 42444352 		.ascii	"BDCR\000"
 2338      00
 2339              	.LASF40:
 2340 0057 5057525F 		.ascii	"PWR_TypeDef\000"
 2340      54797065 
 2340      44656600 
 2341              	.LASF9:
 2342 0063 6C6F6E67 		.ascii	"long long int\000"
 2342      206C6F6E 
 2342      6720696E 
 2342      7400
 2343              	.LASF64:
 2344 0071 48414C5F 		.ascii	"HAL_PWR_DisableSEVOnPend\000"
 2344      5057525F 
 2344      44697361 
 2344      626C6553 
 2344      45564F6E 
 2345              	.LASF43:
 2346 008a 41504231 		.ascii	"APB1RSTR\000"
 2346      52535452 
 2346      00
 2347              	.LASF16:
 2348 0093 43505549 		.ascii	"CPUID\000"
 2348      4400
 2349              	.LASF85:
 2350 0099 474E5520 		.ascii	"GNU C11 6.3.1 20170620 -mcpu=cortex-m3 -mthumb -g -"
 2350      43313120 
 2350      362E332E 
 2350      31203230 
 2350      31373036 
 2351 00cc 67647761 		.ascii	"gdwarf-2 -Os -fomit-frame-pointer\000"
 2351      72662D32 
 2351      202D4F73 
ARM GAS  /tmp/cciAnlD7.s 			page 71


 2351      202D666F 
 2351      6D69742D 
 2352              	.LASF90:
 2353 00ee 76616C75 		.ascii	"value\000"
 2353      6500
 2354              	.LASF70:
 2355 00f4 48414C5F 		.ascii	"HAL_PWR_EnterSTOPMode\000"
 2355      5057525F 
 2355      456E7465 
 2355      7253544F 
 2355      504D6F64 
 2356              	.LASF25:
 2357 010a 42464152 		.ascii	"BFAR\000"
 2357      00
 2358              	.LASF86:
 2359 010f 7372632F 		.ascii	"src/stm32f1xx_hal_pwr.c\000"
 2359      73746D33 
 2359      32663178 
 2359      785F6861 
 2359      6C5F7077 
 2360              	.LASF12:
 2361 0127 75696E74 		.ascii	"uint8_t\000"
 2361      385F7400 
 2362              	.LASF31:
 2363 012f 5343425F 		.ascii	"SCB_Type\000"
 2363      54797065 
 2363      00
 2364              	.LASF46:
 2365 0138 41504231 		.ascii	"APB1ENR\000"
 2365      454E5200 
 2366              	.LASF34:
 2367 0140 41484250 		.ascii	"AHBPrescTable\000"
 2367      72657363 
 2367      5461626C 
 2367      6500
 2368              	.LASF80:
 2369 014e 48414C5F 		.ascii	"HAL_PWR_ConfigPVD\000"
 2369      5057525F 
 2369      436F6E66 
 2369      69675056 
 2369      4400
 2370              	.LASF50:
 2371 0160 44495341 		.ascii	"DISABLE\000"
 2371      424C4500 
 2372              	.LASF2:
 2373 0168 73686F72 		.ascii	"short int\000"
 2373      7420696E 
 2373      7400
 2374              	.LASF17:
 2375 0172 49435352 		.ascii	"ICSR\000"
 2375      00
 2376              	.LASF88:
 2377 0177 5057525F 		.ascii	"PWR_OverloadWfe\000"
 2377      4F766572 
 2377      6C6F6164 
 2377      57666500 
 2378              	.LASF84:
ARM GAS  /tmp/cciAnlD7.s 			page 72


 2379 0187 48414C5F 		.ascii	"HAL_PWR_DeInit\000"
 2379      5057525F 
 2379      4465496E 
 2379      697400
 2380              	.LASF63:
 2381 0196 48414C5F 		.ascii	"HAL_PWR_PVDCallback\000"
 2381      5057525F 
 2381      50564443 
 2381      616C6C62 
 2381      61636B00 
 2382              	.LASF76:
 2383 01aa 57616B65 		.ascii	"WakeUpPinx\000"
 2383      55705069 
 2383      6E7800
 2384              	.LASF60:
 2385 01b5 48414C5F 		.ascii	"HAL_TickFreqTypeDef\000"
 2385      5469636B 
 2385      46726571 
 2385      54797065 
 2385      44656600 
 2386              	.LASF73:
 2387 01c9 48414C5F 		.ascii	"HAL_PWR_EnterSLEEPMode\000"
 2387      5057525F 
 2387      456E7465 
 2387      72534C45 
 2387      45504D6F 
 2388              	.LASF39:
 2389 01e0 45585449 		.ascii	"EXTI_TypeDef\000"
 2389      5F547970 
 2389      65446566 
 2389      00
 2390              	.LASF6:
 2391 01ed 6C6F6E67 		.ascii	"long int\000"
 2391      20696E74 
 2391      00
 2392              	.LASF67:
 2393 01f6 48414C5F 		.ascii	"HAL_PWR_EnableSleepOnExit\000"
 2393      5057525F 
 2393      456E6162 
 2393      6C65536C 
 2393      6565704F 
 2394              	.LASF48:
 2395 0210 5243435F 		.ascii	"RCC_TypeDef\000"
 2395      54797065 
 2395      44656600 
 2396              	.LASF68:
 2397 021c 48414C5F 		.ascii	"HAL_PWR_EnterSTANDBYMode\000"
 2397      5057525F 
 2397      456E7465 
 2397      72535441 
 2397      4E444259 
 2398              	.LASF44:
 2399 0235 41484245 		.ascii	"AHBENR\000"
 2399      4E5200
 2400              	.LASF42:
 2401 023c 41504232 		.ascii	"APB2RSTR\000"
 2401      52535452 
ARM GAS  /tmp/cciAnlD7.s 			page 73


 2401      00
 2402              	.LASF4:
 2403 0245 5F5F7569 		.ascii	"__uint8_t\000"
 2403      6E74385F 
 2403      7400
 2404              	.LASF78:
 2405 024f 48414C5F 		.ascii	"HAL_PWR_DisablePVD\000"
 2405      5057525F 
 2405      44697361 
 2405      626C6550 
 2405      564400
 2406              	.LASF21:
 2407 0262 43465352 		.ascii	"CFSR\000"
 2407      00
 2408              	.LASF89:
 2409 0267 5F5F5242 		.ascii	"__RBIT\000"
 2409      495400
 2410              	.LASF35:
 2411 026e 41504250 		.ascii	"APBPrescTable\000"
 2411      72657363 
 2411      5461626C 
 2411      6500
 2412              	.LASF52:
 2413 027c 6C6F6E67 		.ascii	"long double\000"
 2413      20646F75 
 2413      626C6500 
 2414              	.LASF72:
 2415 0288 53544F50 		.ascii	"STOPEntry\000"
 2415      456E7472 
 2415      7900
 2416              	.LASF19:
 2417 0292 41495243 		.ascii	"AIRCR\000"
 2417      5200
 2418              	.LASF1:
 2419 0298 756E7369 		.ascii	"unsigned char\000"
 2419      676E6564 
 2419      20636861 
 2419      7200
 2420              	.LASF87:
 2421 02a6 2F686F6D 		.ascii	"/home/berndoj/git/stm32tctst/lib/stm32f1hal\000"
 2421      652F6265 
 2421      726E646F 
 2421      6A2F6769 
 2421      742F7374 
 2422              	.LASF45:
 2423 02d2 41504232 		.ascii	"APB2ENR\000"
 2423      454E5200 
 2424              	.LASF79:
 2425 02da 48414C5F 		.ascii	"HAL_PWR_EnablePVD\000"
 2425      5057525F 
 2425      456E6162 
 2425      6C655056 
 2425      4400
 2426              	.LASF75:
 2427 02ec 48414C5F 		.ascii	"HAL_PWR_DisableWakeUpPin\000"
 2427      5057525F 
 2427      44697361 
ARM GAS  /tmp/cciAnlD7.s 			page 74


 2427      626C6557 
 2427      616B6555 
 2428              	.LASF0:
 2429 0305 7369676E 		.ascii	"signed char\000"
 2429      65642063 
 2429      68617200 
 2430              	.LASF10:
 2431 0311 6C6F6E67 		.ascii	"long long unsigned int\000"
 2431      206C6F6E 
 2431      6720756E 
 2431      7369676E 
 2431      65642069 
 2432              	.LASF20:
 2433 0328 53484353 		.ascii	"SHCSR\000"
 2433      5200
 2434              	.LASF62:
 2435 032e 75775469 		.ascii	"uwTickFreq\000"
 2435      636B4672 
 2435      657100
 2436              	.LASF11:
 2437 0339 756E7369 		.ascii	"unsigned int\000"
 2437      676E6564 
 2437      20696E74 
 2437      00
 2438              	.LASF61:
 2439 0346 75775469 		.ascii	"uwTickPrio\000"
 2439      636B5072 
 2439      696F00
 2440              	.LASF37:
 2441 0351 46545352 		.ascii	"FTSR\000"
 2441      00
 2442              	.LASF41:
 2443 0356 43464752 		.ascii	"CFGR\000"
 2443      00
 2444              	.LASF58:
 2445 035b 48414C5F 		.ascii	"HAL_TICK_FREQ_1KHZ\000"
 2445      5449434B 
 2445      5F465245 
 2445      515F314B 
 2445      485A00
 2446              	.LASF3:
 2447 036e 73686F72 		.ascii	"short unsigned int\000"
 2447      7420756E 
 2447      7369676E 
 2447      65642069 
 2447      6E7400
 2448              	.LASF69:
 2449 0381 48414C5F 		.ascii	"HAL_PWR_PVD_IRQHandler\000"
 2449      5057525F 
 2449      5056445F 
 2449      49525148 
 2449      616E646C 
 2450              	.LASF18:
 2451 0398 56544F52 		.ascii	"VTOR\000"
 2451      00
 2452              	.LASF13:
 2453 039d 696E7433 		.ascii	"int32_t\000"
ARM GAS  /tmp/cciAnlD7.s 			page 75


 2453      325F7400 
 2454              	.LASF28:
 2455 03a5 49534152 		.ascii	"ISAR\000"
 2455      00
 2456              	.LASF82:
 2457 03aa 48414C5F 		.ascii	"HAL_PWR_DisableBkUpAccess\000"
 2457      5057525F 
 2457      44697361 
 2457      626C6542 
 2457      6B557041 
 2458              	.LASF23:
 2459 03c4 44465352 		.ascii	"DFSR\000"
 2459      00
 2460              	.LASF66:
 2461 03c9 48414C5F 		.ascii	"HAL_PWR_DisableSleepOnExit\000"
 2461      5057525F 
 2461      44697361 
 2461      626C6553 
 2461      6C656570 
 2462              	.LASF36:
 2463 03e4 52545352 		.ascii	"RTSR\000"
 2463      00
 2464              	.LASF33:
 2465 03e9 53797374 		.ascii	"SystemCoreClock\000"
 2465      656D436F 
 2465      7265436C 
 2465      6F636B00 
 2466              	.LASF57:
 2467 03f9 48414C5F 		.ascii	"HAL_TICK_FREQ_100HZ\000"
 2467      5449434B 
 2467      5F465245 
 2467      515F3130 
 2467      30485A00 
 2468              	.LASF56:
 2469 040d 48414C5F 		.ascii	"HAL_TICK_FREQ_10HZ\000"
 2469      5449434B 
 2469      5F465245 
 2469      515F3130 
 2469      485A00
 2470              	.LASF22:
 2471 0420 48465352 		.ascii	"HFSR\000"
 2471      00
 2472              	.LASF77:
 2473 0425 48414C5F 		.ascii	"HAL_PWR_EnableWakeUpPin\000"
 2473      5057525F 
 2473      456E6162 
 2473      6C655761 
 2473      6B655570 
 2474              	.LASF29:
 2475 043d 52455345 		.ascii	"RESERVED0\000"
 2475      52564544 
 2475      3000
 2476              	.LASF14:
 2477 0447 75696E74 		.ascii	"uint32_t\000"
 2477      33325F74 
 2477      00
 2478              	.LASF8:
ARM GAS  /tmp/cciAnlD7.s 			page 76


 2479 0450 6C6F6E67 		.ascii	"long unsigned int\000"
 2479      20756E73 
 2479      69676E65 
 2479      6420696E 
 2479      7400
 2480              	.LASF7:
 2481 0462 5F5F7569 		.ascii	"__uint32_t\000"
 2481      6E743332 
 2481      5F7400
 2482              	.LASF54:
 2483 046d 4D6F6465 		.ascii	"Mode\000"
 2483      00
 2484              	.LASF5:
 2485 0472 5F5F696E 		.ascii	"__int32_t\000"
 2485      7433325F 
 2485      7400
 2486              	.LASF49:
 2487 047c 52455345 		.ascii	"RESET\000"
 2487      5400
 2488              	.LASF27:
 2489 0482 4D4D4652 		.ascii	"MMFR\000"
 2489      00
 2490              	.LASF83:
 2491 0487 48414C5F 		.ascii	"HAL_PWR_EnableBkUpAccess\000"
 2491      5057525F 
 2491      456E6162 
 2491      6C65426B 
 2491      55704163 
 2492              	.LASF26:
 2493 04a0 41465352 		.ascii	"AFSR\000"
 2493      00
 2494              	.LASF32:
 2495 04a5 49544D5F 		.ascii	"ITM_RxBuffer\000"
 2495      52784275 
 2495      66666572 
 2495      00
 2496              	.LASF53:
 2497 04b2 5056444C 		.ascii	"PVDLevel\000"
 2497      6576656C 
 2497      00
 2498              	.LASF81:
 2499 04bb 73436F6E 		.ascii	"sConfigPVD\000"
 2499      66696750 
 2499      564400
 2500              	.LASF30:
 2501 04c6 43504143 		.ascii	"CPACR\000"
 2501      5200
 2502              	.LASF59:
 2503 04cc 48414C5F 		.ascii	"HAL_TICK_FREQ_DEFAULT\000"
 2503      5449434B 
 2503      5F465245 
 2503      515F4445 
 2503      4641554C 
 2504              	.LASF51:
 2505 04e2 454E4142 		.ascii	"ENABLE\000"
 2505      4C4500
 2506              	.LASF38:
ARM GAS  /tmp/cciAnlD7.s 			page 77


 2507 04e9 53574945 		.ascii	"SWIER\000"
 2507      5200
 2508              		.ident	"GCC: (15:6.3.1+svn253039-1build1) 6.3.1 20170620"
ARM GAS  /tmp/cciAnlD7.s 			page 78


DEFINED SYMBOLS
                            *ABS*:0000000000000000 stm32f1xx_hal_pwr.c
     /tmp/cciAnlD7.s:69     .text:0000000000000000 $t
     /tmp/cciAnlD7.s:75     .text:0000000000000000 PWR_OverloadWfe
     /tmp/cciAnlD7.s:105    .text:0000000000000006 HAL_PWR_DeInit
     /tmp/cciAnlD7.s:125    .text:000000000000001c $d
     /tmp/cciAnlD7.s:129    .text:0000000000000020 $t
     /tmp/cciAnlD7.s:136    .text:0000000000000020 HAL_PWR_EnableBkUpAccess
     /tmp/cciAnlD7.s:151    .text:0000000000000028 $d
     /tmp/cciAnlD7.s:155    .text:000000000000002c $t
     /tmp/cciAnlD7.s:162    .text:000000000000002c HAL_PWR_DisableBkUpAccess
     /tmp/cciAnlD7.s:177    .text:0000000000000034 $d
     /tmp/cciAnlD7.s:181    .text:0000000000000038 $t
     /tmp/cciAnlD7.s:188    .text:0000000000000038 HAL_PWR_ConfigPVD
     /tmp/cciAnlD7.s:254    .text:000000000000009c $d
     /tmp/cciAnlD7.s:259    .text:00000000000000a4 $t
     /tmp/cciAnlD7.s:266    .text:00000000000000a4 HAL_PWR_EnablePVD
     /tmp/cciAnlD7.s:281    .text:00000000000000ac $d
     /tmp/cciAnlD7.s:285    .text:00000000000000b0 $t
     /tmp/cciAnlD7.s:292    .text:00000000000000b0 HAL_PWR_DisablePVD
     /tmp/cciAnlD7.s:307    .text:00000000000000b8 $d
     /tmp/cciAnlD7.s:311    .text:00000000000000bc $t
     /tmp/cciAnlD7.s:318    .text:00000000000000bc HAL_PWR_EnableWakeUpPin
     /tmp/cciAnlD7.s:350    .text:00000000000000d0 $d
     /tmp/cciAnlD7.s:354    .text:00000000000000d4 $t
     /tmp/cciAnlD7.s:361    .text:00000000000000d4 HAL_PWR_DisableWakeUpPin
     /tmp/cciAnlD7.s:392    .text:00000000000000e8 $d
     /tmp/cciAnlD7.s:396    .text:00000000000000ec $t
     /tmp/cciAnlD7.s:403    .text:00000000000000ec HAL_PWR_EnterSLEEPMode
     /tmp/cciAnlD7.s:449    .text:0000000000000108 $d
     /tmp/cciAnlD7.s:453    .text:000000000000010c $t
     /tmp/cciAnlD7.s:460    .text:000000000000010c HAL_PWR_EnterSTOPMode
     /tmp/cciAnlD7.s:528    .text:000000000000014c $d
     /tmp/cciAnlD7.s:533    .text:0000000000000154 $t
     /tmp/cciAnlD7.s:540    .text:0000000000000154 HAL_PWR_EnterSTANDBYMode
     /tmp/cciAnlD7.s:568    .text:000000000000016c $d
     /tmp/cciAnlD7.s:573    .text:0000000000000174 $t
     /tmp/cciAnlD7.s:580    .text:0000000000000174 HAL_PWR_EnableSleepOnExit
     /tmp/cciAnlD7.s:596    .text:0000000000000180 $d
     /tmp/cciAnlD7.s:600    .text:0000000000000184 $t
     /tmp/cciAnlD7.s:607    .text:0000000000000184 HAL_PWR_DisableSleepOnExit
     /tmp/cciAnlD7.s:623    .text:0000000000000190 $d
     /tmp/cciAnlD7.s:627    .text:0000000000000194 $t
     /tmp/cciAnlD7.s:634    .text:0000000000000194 HAL_PWR_EnableSEVOnPend
     /tmp/cciAnlD7.s:650    .text:00000000000001a0 $d
     /tmp/cciAnlD7.s:654    .text:00000000000001a4 $t
     /tmp/cciAnlD7.s:661    .text:00000000000001a4 HAL_PWR_DisableSEVOnPend
     /tmp/cciAnlD7.s:677    .text:00000000000001b0 $d
     /tmp/cciAnlD7.s:681    .text:00000000000001b4 $t
     /tmp/cciAnlD7.s:688    .text:00000000000001b4 HAL_PWR_PVDCallback
     /tmp/cciAnlD7.s:706    .text:00000000000001b6 HAL_PWR_PVD_IRQHandler
     /tmp/cciAnlD7.s:734    .text:00000000000001cc $d
                     .debug_frame:0000000000000010 $d

NO UNDEFINED SYMBOLS
